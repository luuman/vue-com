webpackJsonp([13],{151:function(n,e,t){t(335);var r=t(16)(t(254),t(392),"data-v-6b18775d",null);n.exports=r.exports},235:function(n,e,t){"use strict";t.d(e,"b",function(){return r}),t.d(e,"a",function(){return a}),t(351);var r=function(n,e,t){var r=document.body.scrollWidth,a=document.body.scrollHeight,o=document.createElement("canvas"),i=o.getContext("2d");o.width=r*e,o.height=a*e,o.style.width=r+"px",o.style.height=a+"px",i.scale(e,e);var s={useCORS:!0,canvas:o};window.html2canvas(document.getElementById(n),{canvas:s.canvas,onrendered:function(n){var e=n.toDataURL("image/png");t(e)}})},a=function(n){var e=document.createElement("canvas");e.width=n.width,e.height=n.height,e.getContext("2d").drawImage(n,0,0,n.width,n.height);var t=n.src.substring(n.src.lastIndexOf(".")+1).toLowerCase();return e.toDataURL("image/"+t)}},254:function(n,e,t){"use strict";Object.defineProperty(e,"__esModule",{value:!0});var r=t(235);t(352),e.default={components:{},data:function(){return{imgUrl:"https://avatars2.githubusercontent.com/u/10662852?v=4&s=460",Img:""}},mounted:function(){this.initqrcode()},watch:{},methods:{base64:function(){var n=new Image;n.crossOrigin="Anonymous",n.src=this.imgUrl;var e=this;n.onload=function(){console.log(t.i(r.a)(this)),e.imgUrl=t.i(r.a)(this)}},backImg:function(n){this.$Loading.close(),this.Img=n},showBase:function(){this.$Loading.open("生成中……"),t.i(r.b)("shareContent",3,this.backImg)},initqrcode:function(){var n=new window.QRCode(document.getElementById("qrcode"),{text:"http:// jindo.dev.naver.com/collie",width:428,height:428,colorDark:"#000",colorLight:"#FFF",correctLevel:window.QRCode.CorrectLevel.H});console.log(n)}},filters:{}}},301:function(n,e,t){e=n.exports=t(141)(),e.push([n.i,".mian[data-v-6b18775d]{width:100%;word-break:break-all;background:#fff}.con-answer[data-v-6b18775d]{position:absolute;width:100%;z-index:-1}","",{version:3,sources:["/Users/luuman/Coding/vue-cli/src/views/html-canvas/index.vue"],names:[],mappings:"AAkCA,uBACE,WAAY,AACZ,qBAAsB,AACtB,eAAiB,CAClB,AACD,6BACE,kBAAmB,AACnB,WAAY,AACZ,UAAY,CACb",file:"index.vue",sourcesContent:["/**\n * [when inside]\n  .foo {\n    @include when-inside('.active') {\n      animation: fadeIn 0.3s 1s forwards;\n    }\n  }\n */\n/**\n * [clearfix]\n * @include clearfix();\n */\n/**\n * [position absolute]\n * @include abs-pos(10px, 10px, 5px, 15px);\n */\n/**\n * [respond-to]\n * --->mobile\n * 480px xs 768px sm 992px md 1200px lg\n * <----PC\n * 1200px \n  @include respond-to(sm) {\n    color: tomato;\n  }\n */\n/**\n * [flexible]\n * @include data-dpr(font-size, 14px)\n * @include fon-size(14px)\n */\n/**\n * [createCircleAnimation description]\n */\n.mian[data-v-6b18775d] {\n  width: 100%;\n  word-break: break-all;\n  background: #FFF;\n}\n.con-answer[data-v-6b18775d] {\n  position: absolute;\n  width: 100%;\n  z-index: -1;\n}\n"],sourceRoot:""}])},335:function(n,e,t){var r=t(301);"string"==typeof r&&(r=[[n.i,r,""]]),r.locals&&(n.exports=r.locals);t(142)("1f3f1026",r,!0)},346:function(n,e){n.exports='/*\n  html2canvas 0.4.1 <http://html2canvas.hertzen.com>\n  Copyright (c) 2013 Niklas von Hertzen\n\n  Released under MIT License\n*/\n\n(function(window, document, undefined){\n\n"use strict";\n\nvar _html2canvas = {},\npreviousElement,\ncomputedCSS,\nhtml2canvas;\n\n_html2canvas.Util = {};\n\n_html2canvas.Util.log = function(a) {\n  if (_html2canvas.logging && window.console && window.console.log) {\n    window.console.log(a);\n  }\n};\n\n_html2canvas.Util.trimText = (function(isNative){\n  return function(input) {\n    return isNative ? isNative.apply(input) : ((input || \'\') + \'\').replace( /^\\s+|\\s+$/g , \'\' );\n  };\n})(String.prototype.trim);\n\n_html2canvas.Util.asFloat = function(v) {\n  return parseFloat(v);\n};\n\n(function() {\n  // TODO: support all possible length values\n  var TEXT_SHADOW_PROPERTY = /((rgba|rgb)\\([^\\)]+\\)(\\s-?\\d+px){0,})/g;\n  var TEXT_SHADOW_VALUES = /(-?\\d+px)|(#.+)|(rgb\\(.+\\))|(rgba\\(.+\\))/g;\n  _html2canvas.Util.parseTextShadows = function (value) {\n    if (!value || value === \'none\') {\n      return [];\n    }\n\n    // find multiple shadow declarations\n    var shadows = value.match(TEXT_SHADOW_PROPERTY),\n      results = [];\n    for (var i = 0; shadows && (i < shadows.length); i++) {\n      var s = shadows[i].match(TEXT_SHADOW_VALUES);\n      results.push({\n        color: s[0],\n        offsetX: s[1] ? s[1].replace(\'px\', \'\') : 0,\n        offsetY: s[2] ? s[2].replace(\'px\', \'\') : 0,\n        blur: s[3] ? s[3].replace(\'px\', \'\') : 0\n      });\n    }\n    return results;\n  };\n})();\n\n\n_html2canvas.Util.parseBackgroundImage = function (value) {\n    var whitespace = \' \\r\\n\\t\',\n        method, definition, prefix, prefix_i, block, results = [],\n        c, mode = 0, numParen = 0, quote, args;\n\n    var appendResult = function(){\n        if(method) {\n            if(definition.substr( 0, 1 ) === \'"\') {\n                definition = definition.substr( 1, definition.length - 2 );\n            }\n            if(definition) {\n                args.push(definition);\n            }\n            if(method.substr( 0, 1 ) === \'-\' &&\n                    (prefix_i = method.indexOf( \'-\', 1 ) + 1) > 0) {\n                prefix = method.substr( 0, prefix_i);\n                method = method.substr( prefix_i );\n            }\n            results.push({\n                prefix: prefix,\n                method: method.toLowerCase(),\n                value: block,\n                args: args\n            });\n        }\n        args = []; //for some odd reason, setting .length = 0 didn\'t work in safari\n        method =\n            prefix =\n            definition =\n            block = \'\';\n    };\n\n    appendResult();\n    for(var i = 0, ii = value.length; i<ii; i++) {\n        c = value[i];\n        if(mode === 0 && whitespace.indexOf( c ) > -1){\n            continue;\n        }\n        switch(c) {\n            case \'"\':\n                if(!quote) {\n                    quote = c;\n                }\n                else if(quote === c) {\n                    quote = null;\n                }\n                break;\n\n            case \'(\':\n                if(quote) { break; }\n                else if(mode === 0) {\n                    mode = 1;\n                    block += c;\n                    continue;\n                } else {\n                    numParen++;\n                }\n                break;\n\n            case \')\':\n                if(quote) { break; }\n                else if(mode === 1) {\n                    if(numParen === 0) {\n                        mode = 0;\n                        block += c;\n                        appendResult();\n                        continue;\n                    } else {\n                        numParen--;\n                    }\n                }\n                break;\n\n            case \',\':\n                if(quote) { break; }\n                else if(mode === 0) {\n                    appendResult();\n                    continue;\n                }\n                else if (mode === 1) {\n                    if(numParen === 0 && !method.match(/^url$/i)) {\n                        args.push(definition);\n                        definition = \'\';\n                        block += c;\n                        continue;\n                    }\n                }\n                break;\n        }\n\n        block += c;\n        if(mode === 0) { method += c; }\n        else { definition += c; }\n    }\n    appendResult();\n\n    return results;\n};\n\n_html2canvas.Util.Bounds = function (element) {\n  var clientRect, bounds = {};\n\n  if (element.getBoundingClientRect){\n    clientRect = element.getBoundingClientRect();\n\n    // TODO add scroll position to bounds, so no scrolling of window necessary\n    bounds.top = clientRect.top;\n    bounds.bottom = clientRect.bottom || (clientRect.top + clientRect.height);\n    bounds.left = clientRect.left;\n\n    bounds.width = element.offsetWidth;\n    bounds.height = element.offsetHeight;\n  }\n\n  return bounds;\n};\n\n// TODO ideally, we\'d want everything to go through this function instead of Util.Bounds,\n// but would require further work to calculate the correct positions for elements with offsetParents\n_html2canvas.Util.OffsetBounds = function (element) {\n  var parent = element.offsetParent ? _html2canvas.Util.OffsetBounds(element.offsetParent) : {top: 0, left: 0};\n\n  return {\n    top: element.offsetTop + parent.top,\n    bottom: element.offsetTop + element.offsetHeight + parent.top,\n    left: element.offsetLeft + parent.left,\n    width: element.offsetWidth,\n    height: element.offsetHeight\n  };\n};\n\nfunction toPX(element, attribute, value ) {\n    var rsLeft = element.runtimeStyle && element.runtimeStyle[attribute],\n        left,\n        style = element.style;\n\n    // Check if we are not dealing with pixels, (Opera has issues with this)\n    // Ported from jQuery css.js\n    // From the awesome hack by Dean Edwards\n    // http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291\n\n    // If we\'re not dealing with a regular pixel number\n    // but a number that has a weird ending, we need to convert it to pixels\n\n    if ( !/^-?[0-9]+\\.?[0-9]*(?:px)?$/i.test( value ) && /^-?\\d/.test(value) ) {\n        // Remember the original values\n        left = style.left;\n\n        // Put in the new values to get a computed value out\n        if (rsLeft) {\n            element.runtimeStyle.left = element.currentStyle.left;\n        }\n        style.left = attribute === "fontSize" ? "1em" : (value || 0);\n        value = style.pixelLeft + "px";\n\n        // Revert the changed values\n        style.left = left;\n        if (rsLeft) {\n            element.runtimeStyle.left = rsLeft;\n        }\n    }\n\n    if (!/^(thin|medium|thick)$/i.test(value)) {\n        return Math.round(parseFloat(value)) + "px";\n    }\n\n    return value;\n}\n\nfunction asInt(val) {\n    return parseInt(val, 10);\n}\n\nfunction parseBackgroundSizePosition(value, element, attribute, index) {\n    value = (value || \'\').split(\',\');\n    value = value[index || 0] || value[0] || \'auto\';\n    value = _html2canvas.Util.trimText(value).split(\' \');\n\n    if(attribute === \'backgroundSize\' && (!value[0] || value[0].match(/cover|contain|auto/))) {\n        //these values will be handled in the parent function\n    } else {\n        value[0] = (value[0].indexOf( "%" ) === -1) ? toPX(element, attribute + "X", value[0]) : value[0];\n        if(value[1] === undefined) {\n            if(attribute === \'backgroundSize\') {\n                value[1] = \'auto\';\n                return value;\n            } else {\n                // IE 9 doesn\'t return double digit always\n                value[1] = value[0];\n            }\n        }\n        value[1] = (value[1].indexOf("%") === -1) ? toPX(element, attribute + "Y", value[1]) : value[1];\n    }\n    return value;\n}\n\n_html2canvas.Util.getCSS = function (element, attribute, index) {\n    if (previousElement !== element) {\n      computedCSS = document.defaultView.getComputedStyle(element, null);\n    }\n\n    var value = computedCSS[attribute];\n\n    if (/^background(Size|Position)$/.test(attribute)) {\n        return parseBackgroundSizePosition(value, element, attribute, index);\n    } else if (/border(Top|Bottom)(Left|Right)Radius/.test(attribute)) {\n      var arr = value.split(" ");\n      if (arr.length <= 1) {\n          arr[1] = arr[0];\n      }\n      return arr.map(asInt);\n    }\n\n  return value;\n};\n\n_html2canvas.Util.resizeBounds = function( current_width, current_height, target_width, target_height, stretch_mode ){\n  var target_ratio = target_width / target_height,\n    current_ratio = current_width / current_height,\n    output_width, output_height;\n\n  if(!stretch_mode || stretch_mode === \'auto\') {\n    output_width = target_width;\n    output_height = target_height;\n  } else if(target_ratio < current_ratio ^ stretch_mode === \'contain\') {\n    output_height = target_height;\n    output_width = target_height * current_ratio;\n  } else {\n    output_width = target_width;\n    output_height = target_width / current_ratio;\n  }\n\n  return {\n    width: output_width,\n    height: output_height\n  };\n};\n\nfunction backgroundBoundsFactory( prop, el, bounds, image, imageIndex, backgroundSize ) {\n    var bgposition =  _html2canvas.Util.getCSS( el, prop, imageIndex ) ,\n    topPos,\n    left,\n    percentage,\n    val;\n\n    if (bgposition.length === 1){\n      val = bgposition[0];\n\n      bgposition = [];\n\n      bgposition[0] = val;\n      bgposition[1] = val;\n    }\n\n    if (bgposition[0].toString().indexOf("%") !== -1){\n      percentage = (parseFloat(bgposition[0])/100);\n      left = bounds.width * percentage;\n      if(prop !== \'backgroundSize\') {\n        left -= (backgroundSize || image).width*percentage;\n      }\n    } else {\n      if(prop === \'backgroundSize\') {\n        if(bgposition[0] === \'auto\') {\n          left = image.width;\n        } else {\n          if (/contain|cover/.test(bgposition[0])) {\n            var resized = _html2canvas.Util.resizeBounds(image.width, image.height, bounds.width, bounds.height, bgposition[0]);\n            left = resized.width;\n            topPos = resized.height;\n          } else {\n            left = parseInt(bgposition[0], 10);\n          }\n        }\n      } else {\n        left = parseInt( bgposition[0], 10);\n      }\n    }\n\n\n    if(bgposition[1] === \'auto\') {\n      topPos = left / image.width * image.height;\n    } else if (bgposition[1].toString().indexOf("%") !== -1){\n      percentage = (parseFloat(bgposition[1])/100);\n      topPos =  bounds.height * percentage;\n      if(prop !== \'backgroundSize\') {\n        topPos -= (backgroundSize || image).height * percentage;\n      }\n\n    } else {\n      topPos = parseInt(bgposition[1],10);\n    }\n\n    return [left, topPos];\n}\n\n_html2canvas.Util.BackgroundPosition = function( el, bounds, image, imageIndex, backgroundSize ) {\n    var result = backgroundBoundsFactory( \'backgroundPosition\', el, bounds, image, imageIndex, backgroundSize );\n    return { left: result[0], top: result[1] };\n};\n\n_html2canvas.Util.BackgroundSize = function( el, bounds, image, imageIndex ) {\n    var result = backgroundBoundsFactory( \'backgroundSize\', el, bounds, image, imageIndex );\n    return { width: result[0], height: result[1] };\n};\n\n_html2canvas.Util.Extend = function (options, defaults) {\n  for (var key in options) {\n    if (options.hasOwnProperty(key)) {\n      defaults[key] = options[key];\n    }\n  }\n  return defaults;\n};\n\n\n/*\n * Derived from jQuery.contents()\n * Copyright 2010, John Resig\n * Dual licensed under the MIT or GPL Version 2 licenses.\n * http://jquery.org/license\n */\n_html2canvas.Util.Children = function( elem ) {\n  var children;\n  try {\n    children = (elem.nodeName && elem.nodeName.toUpperCase() === "IFRAME") ? elem.contentDocument || elem.contentWindow.document : (function(array) {\n      var ret = [];\n      if (array !== null) {\n        (function(first, second ) {\n          var i = first.length,\n          j = 0;\n\n          if (typeof second.length === "number") {\n            for (var l = second.length; j < l; j++) {\n              first[i++] = second[j];\n            }\n          } else {\n            while (second[j] !== undefined) {\n              first[i++] = second[j++];\n            }\n          }\n\n          first.length = i;\n\n          return first;\n        })(ret, array);\n      }\n      return ret;\n    })(elem.childNodes);\n\n  } catch (ex) {\n    _html2canvas.Util.log("html2canvas.Util.Children failed with exception: " + ex.message);\n    children = [];\n  }\n  return children;\n};\n\n_html2canvas.Util.isTransparent = function(backgroundColor) {\n  return (backgroundColor === "transparent" || backgroundColor === "rgba(0, 0, 0, 0)");\n};\n_html2canvas.Util.Font = (function () {\n\n  var fontData = {};\n\n  return function(font, fontSize, doc) {\n    if (fontData[font + "-" + fontSize] !== undefined) {\n      return fontData[font + "-" + fontSize];\n    }\n\n    var container = doc.createElement(\'div\'),\n    img = doc.createElement(\'img\'),\n    span = doc.createElement(\'span\'),\n    sampleText = \'Hidden Text\',\n    baseline,\n    middle,\n    metricsObj;\n\n    container.style.visibility = "hidden";\n    container.style.fontFamily = font;\n    container.style.fontSize = fontSize;\n    container.style.margin = 0;\n    container.style.padding = 0;\n\n    doc.body.appendChild(container);\n\n    // http://probablyprogramming.com/2009/03/15/the-tiniest-gif-ever (handtinywhite.gif)\n    img.src = "data:image/gif;base64,R0lGODlhAQABAIABAP///wAAACwAAAAAAQABAAACAkQBADs=";\n    img.width = 1;\n    img.height = 1;\n\n    img.style.margin = 0;\n    img.style.padding = 0;\n    img.style.verticalAlign = "baseline";\n\n    span.style.fontFamily = font;\n    span.style.fontSize = fontSize;\n    span.style.margin = 0;\n    span.style.padding = 0;\n\n    span.appendChild(doc.createTextNode(sampleText));\n    container.appendChild(span);\n    container.appendChild(img);\n    baseline = (img.offsetTop - span.offsetTop) + 1;\n\n    container.removeChild(span);\n    container.appendChild(doc.createTextNode(sampleText));\n\n    container.style.lineHeight = "normal";\n    img.style.verticalAlign = "super";\n\n    middle = (img.offsetTop-container.offsetTop) + 1;\n    metricsObj = {\n      baseline: baseline,\n      lineWidth: 1,\n      middle: middle\n    };\n\n    fontData[font + "-" + fontSize] = metricsObj;\n\n    doc.body.removeChild(container);\n\n    return metricsObj;\n  };\n})();\n\n(function(){\n  var Util = _html2canvas.Util,\n    Generate = {};\n\n  _html2canvas.Generate = Generate;\n\n  var reGradients = [\n  /^(-webkit-linear-gradient)\\(([a-z\\s]+)([\\w\\d\\.\\s,%\\(\\)]+)\\)$/,\n  /^(-o-linear-gradient)\\(([a-z\\s]+)([\\w\\d\\.\\s,%\\(\\)]+)\\)$/,\n  /^(-webkit-gradient)\\((linear|radial),\\s((?:\\d{1,3}%?)\\s(?:\\d{1,3}%?),\\s(?:\\d{1,3}%?)\\s(?:\\d{1,3}%?))([\\w\\d\\.\\s,%\\(\\)\\-]+)\\)$/,\n  /^(-moz-linear-gradient)\\(((?:\\d{1,3}%?)\\s(?:\\d{1,3}%?))([\\w\\d\\.\\s,%\\(\\)]+)\\)$/,\n  /^(-webkit-radial-gradient)\\(((?:\\d{1,3}%?)\\s(?:\\d{1,3}%?)),\\s(\\w+)\\s([a-z\\-]+)([\\w\\d\\.\\s,%\\(\\)]+)\\)$/,\n  /^(-moz-radial-gradient)\\(((?:\\d{1,3}%?)\\s(?:\\d{1,3}%?)),\\s(\\w+)\\s?([a-z\\-]*)([\\w\\d\\.\\s,%\\(\\)]+)\\)$/,\n  /^(-o-radial-gradient)\\(((?:\\d{1,3}%?)\\s(?:\\d{1,3}%?)),\\s(\\w+)\\s([a-z\\-]+)([\\w\\d\\.\\s,%\\(\\)]+)\\)$/\n  ];\n\n  /*\n * TODO: Add IE10 vendor prefix (-ms) support\n * TODO: Add W3C gradient (linear-gradient) support\n * TODO: Add old Webkit -webkit-gradient(radial, ...) support\n * TODO: Maybe some RegExp optimizations are possible ;o)\n */\n  Generate.parseGradient = function(css, bounds) {\n    var gradient, i, len = reGradients.length, m1, stop, m2, m2Len, step, m3, tl,tr,br,bl;\n\n    for(i = 0; i < len; i+=1){\n      m1 = css.match(reGradients[i]);\n      if(m1) {\n        break;\n      }\n    }\n\n    if(m1) {\n      switch(m1[1]) {\n        case \'-webkit-linear-gradient\':\n        case \'-o-linear-gradient\':\n\n          gradient = {\n            type: \'linear\',\n            x0: null,\n            y0: null,\n            x1: null,\n            y1: null,\n            colorStops: []\n          };\n\n          // get coordinates\n          m2 = m1[2].match(/\\w+/g);\n          if(m2){\n            m2Len = m2.length;\n            for(i = 0; i < m2Len; i+=1){\n              switch(m2[i]) {\n                case \'top\':\n                  gradient.y0 = 0;\n                  gradient.y1 = bounds.height;\n                  break;\n\n                case \'right\':\n                  gradient.x0 = bounds.width;\n                  gradient.x1 = 0;\n                  break;\n\n                case \'bottom\':\n                  gradient.y0 = bounds.height;\n                  gradient.y1 = 0;\n                  break;\n\n                case \'left\':\n                  gradient.x0 = 0;\n                  gradient.x1 = bounds.width;\n                  break;\n              }\n            }\n          }\n          if(gradient.x0 === null && gradient.x1 === null){ // center\n            gradient.x0 = gradient.x1 = bounds.width / 2;\n          }\n          if(gradient.y0 === null && gradient.y1 === null){ // center\n            gradient.y0 = gradient.y1 = bounds.height / 2;\n          }\n\n          // get colors and stops\n          m2 = m1[3].match(/((?:rgb|rgba)\\(\\d{1,3},\\s\\d{1,3},\\s\\d{1,3}(?:,\\s[0-9\\.]+)?\\)(?:\\s\\d{1,3}(?:%|px))?)+/g);\n          if(m2){\n            m2Len = m2.length;\n            step = 1 / Math.max(m2Len - 1, 1);\n            for(i = 0; i < m2Len; i+=1){\n              m3 = m2[i].match(/((?:rgb|rgba)\\(\\d{1,3},\\s\\d{1,3},\\s\\d{1,3}(?:,\\s[0-9\\.]+)?\\))\\s*(\\d{1,3})?(%|px)?/);\n              if(m3[2]){\n                stop = parseFloat(m3[2]);\n                if(m3[3] === \'%\'){\n                  stop /= 100;\n                } else { // px - stupid opera\n                  stop /= bounds.width;\n                }\n              } else {\n                stop = i * step;\n              }\n              gradient.colorStops.push({\n                color: m3[1],\n                stop: stop\n              });\n            }\n          }\n          break;\n\n        case \'-webkit-gradient\':\n\n          gradient = {\n            type: m1[2] === \'radial\' ? \'circle\' : m1[2], // TODO: Add radial gradient support for older mozilla definitions\n            x0: 0,\n            y0: 0,\n            x1: 0,\n            y1: 0,\n            colorStops: []\n          };\n\n          // get coordinates\n          m2 = m1[3].match(/(\\d{1,3})%?\\s(\\d{1,3})%?,\\s(\\d{1,3})%?\\s(\\d{1,3})%?/);\n          if(m2){\n            gradient.x0 = (m2[1] * bounds.width) / 100;\n            gradient.y0 = (m2[2] * bounds.height) / 100;\n            gradient.x1 = (m2[3] * bounds.width) / 100;\n            gradient.y1 = (m2[4] * bounds.height) / 100;\n          }\n\n          // get colors and stops\n          m2 = m1[4].match(/((?:from|to|color-stop)\\((?:[0-9\\.]+,\\s)?(?:rgb|rgba)\\(\\d{1,3},\\s\\d{1,3},\\s\\d{1,3}(?:,\\s[0-9\\.]+)?\\)\\))+/g);\n          if(m2){\n            m2Len = m2.length;\n            for(i = 0; i < m2Len; i+=1){\n              m3 = m2[i].match(/(from|to|color-stop)\\(([0-9\\.]+)?(?:,\\s)?((?:rgb|rgba)\\(\\d{1,3},\\s\\d{1,3},\\s\\d{1,3}(?:,\\s[0-9\\.]+)?\\))\\)/);\n              stop = parseFloat(m3[2]);\n              if(m3[1] === \'from\') {\n                stop = 0.0;\n              }\n              if(m3[1] === \'to\') {\n                stop = 1.0;\n              }\n              gradient.colorStops.push({\n                color: m3[3],\n                stop: stop\n              });\n            }\n          }\n          break;\n\n        case \'-moz-linear-gradient\':\n\n          gradient = {\n            type: \'linear\',\n            x0: 0,\n            y0: 0,\n            x1: 0,\n            y1: 0,\n            colorStops: []\n          };\n\n          // get coordinates\n          m2 = m1[2].match(/(\\d{1,3})%?\\s(\\d{1,3})%?/);\n\n          // m2[1] == 0%   -> left\n          // m2[1] == 50%  -> center\n          // m2[1] == 100% -> right\n\n          // m2[2] == 0%   -> top\n          // m2[2] == 50%  -> center\n          // m2[2] == 100% -> bottom\n\n          if(m2){\n            gradient.x0 = (m2[1] * bounds.width) / 100;\n            gradient.y0 = (m2[2] * bounds.height) / 100;\n            gradient.x1 = bounds.width - gradient.x0;\n            gradient.y1 = bounds.height - gradient.y0;\n          }\n\n          // get colors and stops\n          m2 = m1[3].match(/((?:rgb|rgba)\\(\\d{1,3},\\s\\d{1,3},\\s\\d{1,3}(?:,\\s[0-9\\.]+)?\\)(?:\\s\\d{1,3}%)?)+/g);\n          if(m2){\n            m2Len = m2.length;\n            step = 1 / Math.max(m2Len - 1, 1);\n            for(i = 0; i < m2Len; i+=1){\n              m3 = m2[i].match(/((?:rgb|rgba)\\(\\d{1,3},\\s\\d{1,3},\\s\\d{1,3}(?:,\\s[0-9\\.]+)?\\))\\s*(\\d{1,3})?(%)?/);\n              if(m3[2]){\n                stop = parseFloat(m3[2]);\n                if(m3[3]){ // percentage\n                  stop /= 100;\n                }\n              } else {\n                stop = i * step;\n              }\n              gradient.colorStops.push({\n                color: m3[1],\n                stop: stop\n              });\n            }\n          }\n          break;\n\n        case \'-webkit-radial-gradient\':\n        case \'-moz-radial-gradient\':\n        case \'-o-radial-gradient\':\n\n          gradient = {\n            type: \'circle\',\n            x0: 0,\n            y0: 0,\n            x1: bounds.width,\n            y1: bounds.height,\n            cx: 0,\n            cy: 0,\n            rx: 0,\n            ry: 0,\n            colorStops: []\n          };\n\n          // center\n          m2 = m1[2].match(/(\\d{1,3})%?\\s(\\d{1,3})%?/);\n          if(m2){\n            gradient.cx = (m2[1] * bounds.width) / 100;\n            gradient.cy = (m2[2] * bounds.height) / 100;\n          }\n\n          // size\n          m2 = m1[3].match(/\\w+/);\n          m3 = m1[4].match(/[a-z\\-]*/);\n          if(m2 && m3){\n            switch(m3[0]){\n              case \'farthest-corner\':\n              case \'cover\': // is equivalent to farthest-corner\n              case \'\': // mozilla removes "cover" from definition :(\n                tl = Math.sqrt(Math.pow(gradient.cx, 2) + Math.pow(gradient.cy, 2));\n                tr = Math.sqrt(Math.pow(gradient.cx, 2) + Math.pow(gradient.y1 - gradient.cy, 2));\n                br = Math.sqrt(Math.pow(gradient.x1 - gradient.cx, 2) + Math.pow(gradient.y1 - gradient.cy, 2));\n                bl = Math.sqrt(Math.pow(gradient.x1 - gradient.cx, 2) + Math.pow(gradient.cy, 2));\n                gradient.rx = gradient.ry = Math.max(tl, tr, br, bl);\n                break;\n              case \'closest-corner\':\n                tl = Math.sqrt(Math.pow(gradient.cx, 2) + Math.pow(gradient.cy, 2));\n                tr = Math.sqrt(Math.pow(gradient.cx, 2) + Math.pow(gradient.y1 - gradient.cy, 2));\n                br = Math.sqrt(Math.pow(gradient.x1 - gradient.cx, 2) + Math.pow(gradient.y1 - gradient.cy, 2));\n                bl = Math.sqrt(Math.pow(gradient.x1 - gradient.cx, 2) + Math.pow(gradient.cy, 2));\n                gradient.rx = gradient.ry = Math.min(tl, tr, br, bl);\n                break;\n              case \'farthest-side\':\n                if(m2[0] === \'circle\'){\n                  gradient.rx = gradient.ry = Math.max(\n                    gradient.cx,\n                    gradient.cy,\n                    gradient.x1 - gradient.cx,\n                    gradient.y1 - gradient.cy\n                    );\n                } else { // ellipse\n\n                  gradient.type = m2[0];\n\n                  gradient.rx = Math.max(\n                    gradient.cx,\n                    gradient.x1 - gradient.cx\n                    );\n                  gradient.ry = Math.max(\n                    gradient.cy,\n                    gradient.y1 - gradient.cy\n                    );\n                }\n                break;\n              case \'closest-side\':\n              case \'contain\': // is equivalent to closest-side\n                if(m2[0] === \'circle\'){\n                  gradient.rx = gradient.ry = Math.min(\n                    gradient.cx,\n                    gradient.cy,\n                    gradient.x1 - gradient.cx,\n                    gradient.y1 - gradient.cy\n                    );\n                } else { // ellipse\n\n                  gradient.type = m2[0];\n\n                  gradient.rx = Math.min(\n                    gradient.cx,\n                    gradient.x1 - gradient.cx\n                    );\n                  gradient.ry = Math.min(\n                    gradient.cy,\n                    gradient.y1 - gradient.cy\n                    );\n                }\n                break;\n\n            // TODO: add support for "30px 40px" sizes (webkit only)\n            }\n          }\n\n          // color stops\n          m2 = m1[5].match(/((?:rgb|rgba)\\(\\d{1,3},\\s\\d{1,3},\\s\\d{1,3}(?:,\\s[0-9\\.]+)?\\)(?:\\s\\d{1,3}(?:%|px))?)+/g);\n          if(m2){\n            m2Len = m2.length;\n            step = 1 / Math.max(m2Len - 1, 1);\n            for(i = 0; i < m2Len; i+=1){\n              m3 = m2[i].match(/((?:rgb|rgba)\\(\\d{1,3},\\s\\d{1,3},\\s\\d{1,3}(?:,\\s[0-9\\.]+)?\\))\\s*(\\d{1,3})?(%|px)?/);\n              if(m3[2]){\n                stop = parseFloat(m3[2]);\n                if(m3[3] === \'%\'){\n                  stop /= 100;\n                } else { // px - stupid opera\n                  stop /= bounds.width;\n                }\n              } else {\n                stop = i * step;\n              }\n              gradient.colorStops.push({\n                color: m3[1],\n                stop: stop\n              });\n            }\n          }\n          break;\n      }\n    }\n\n    return gradient;\n  };\n\n  function addScrollStops(grad) {\n    return function(colorStop) {\n      try {\n        grad.addColorStop(colorStop.stop, colorStop.color);\n      }\n      catch(e) {\n        Util.log([\'failed to add color stop: \', e, \'; tried to add: \', colorStop]);\n      }\n    };\n  }\n\n  Generate.Gradient = function(src, bounds) {\n    if(bounds.width === 0 || bounds.height === 0) {\n      return;\n    }\n\n    var canvas = document.createElement(\'canvas\'),\n    ctx = canvas.getContext(\'2d\'),\n    gradient, grad;\n\n    canvas.width = bounds.width;\n    canvas.height = bounds.height;\n\n    // TODO: add support for multi defined background gradients\n    gradient = _html2canvas.Generate.parseGradient(src, bounds);\n\n    if(gradient) {\n      switch(gradient.type) {\n        case \'linear\':\n          grad = ctx.createLinearGradient(gradient.x0, gradient.y0, gradient.x1, gradient.y1);\n          gradient.colorStops.forEach(addScrollStops(grad));\n          ctx.fillStyle = grad;\n          ctx.fillRect(0, 0, bounds.width, bounds.height);\n          break;\n\n        case \'circle\':\n          grad = ctx.createRadialGradient(gradient.cx, gradient.cy, 0, gradient.cx, gradient.cy, gradient.rx);\n          gradient.colorStops.forEach(addScrollStops(grad));\n          ctx.fillStyle = grad;\n          ctx.fillRect(0, 0, bounds.width, bounds.height);\n          break;\n\n        case \'ellipse\':\n          var canvasRadial = document.createElement(\'canvas\'),\n            ctxRadial = canvasRadial.getContext(\'2d\'),\n            ri = Math.max(gradient.rx, gradient.ry),\n            di = ri * 2;\n\n          canvasRadial.width = canvasRadial.height = di;\n\n          grad = ctxRadial.createRadialGradient(gradient.rx, gradient.ry, 0, gradient.rx, gradient.ry, ri);\n          gradient.colorStops.forEach(addScrollStops(grad));\n\n          ctxRadial.fillStyle = grad;\n          ctxRadial.fillRect(0, 0, di, di);\n\n          ctx.fillStyle = gradient.colorStops[gradient.colorStops.length - 1].color;\n          ctx.fillRect(0, 0, canvas.width, canvas.height);\n          ctx.drawImage(canvasRadial, gradient.cx - gradient.rx, gradient.cy - gradient.ry, 2 * gradient.rx, 2 * gradient.ry);\n          break;\n      }\n    }\n\n    return canvas;\n  };\n\n  Generate.ListAlpha = function(number) {\n    var tmp = "",\n    modulus;\n\n    do {\n      modulus = number % 26;\n      tmp = String.fromCharCode((modulus) + 64) + tmp;\n      number = number / 26;\n    }while((number*26) > 26);\n\n    return tmp;\n  };\n\n  Generate.ListRoman = function(number) {\n    var romanArray = ["M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I"],\n    decimal = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1],\n    roman = "",\n    v,\n    len = romanArray.length;\n\n    if (number <= 0 || number >= 4000) {\n      return number;\n    }\n\n    for (v=0; v < len; v+=1) {\n      while (number >= decimal[v]) {\n        number -= decimal[v];\n        roman += romanArray[v];\n      }\n    }\n\n    return roman;\n  };\n})();\nfunction h2cRenderContext(width, height) {\n  var storage = [];\n  return {\n    storage: storage,\n    width: width,\n    height: height,\n    clip: function() {\n      storage.push({\n        type: "function",\n        name: "clip",\n        \'arguments\': arguments\n      });\n    },\n    translate: function() {\n      storage.push({\n        type: "function",\n        name: "translate",\n        \'arguments\': arguments\n      });\n    },\n    fill: function() {\n      storage.push({\n        type: "function",\n        name: "fill",\n        \'arguments\': arguments\n      });\n    },\n    save: function() {\n      storage.push({\n        type: "function",\n        name: "save",\n        \'arguments\': arguments\n      });\n    },\n    restore: function() {\n      storage.push({\n        type: "function",\n        name: "restore",\n        \'arguments\': arguments\n      });\n    },\n    fillRect: function () {\n      storage.push({\n        type: "function",\n        name: "fillRect",\n        \'arguments\': arguments\n      });\n    },\n    createPattern: function() {\n      storage.push({\n        type: "function",\n        name: "createPattern",\n        \'arguments\': arguments\n      });\n    },\n    drawShape: function() {\n\n      var shape = [];\n\n      storage.push({\n        type: "function",\n        name: "drawShape",\n        \'arguments\': shape\n      });\n\n      return {\n        moveTo: function() {\n          shape.push({\n            name: "moveTo",\n            \'arguments\': arguments\n          });\n        },\n        lineTo: function() {\n          shape.push({\n            name: "lineTo",\n            \'arguments\': arguments\n          });\n        },\n        arcTo: function() {\n          shape.push({\n            name: "arcTo",\n            \'arguments\': arguments\n          });\n        },\n        bezierCurveTo: function() {\n          shape.push({\n            name: "bezierCurveTo",\n            \'arguments\': arguments\n          });\n        },\n        quadraticCurveTo: function() {\n          shape.push({\n            name: "quadraticCurveTo",\n            \'arguments\': arguments\n          });\n        }\n      };\n\n    },\n    drawImage: function () {\n      storage.push({\n        type: "function",\n        name: "drawImage",\n        \'arguments\': arguments\n      });\n    },\n    fillText: function () {\n      storage.push({\n        type: "function",\n        name: "fillText",\n        \'arguments\': arguments\n      });\n    },\n    setVariable: function (variable, value) {\n      storage.push({\n        type: "variable",\n        name: variable,\n        \'arguments\': value\n      });\n      return value;\n    }\n  };\n}\n_html2canvas.Parse = function (images, options) {\n  window.scroll(0,0);\n\n  var element = (( options.elements === undefined ) ? document.body : options.elements[0]), // select body by default\n  numDraws = 0,\n  doc = element.ownerDocument,\n  Util = _html2canvas.Util,\n  support = Util.Support(options, doc),\n  ignoreElementsRegExp = new RegExp("(" + options.ignoreElements + ")"),\n  body = doc.body,\n  getCSS = Util.getCSS,\n  pseudoHide = "___html2canvas___pseudoelement",\n  hidePseudoElements = doc.createElement(\'style\');\n\n  hidePseudoElements.innerHTML = \'.\' + pseudoHide + \'-before:before { content: "" !important; display: none !important; }\' +\n  \'.\' + pseudoHide + \'-after:after { content: "" !important; display: none !important; }\';\n\n  body.appendChild(hidePseudoElements);\n\n  images = images || {};\n\n  function documentWidth () {\n    return Math.max(\n      Math.max(doc.body.scrollWidth, doc.documentElement.scrollWidth),\n      Math.max(doc.body.offsetWidth, doc.documentElement.offsetWidth),\n      Math.max(doc.body.clientWidth, doc.documentElement.clientWidth)\n      );\n  }\n\n  function documentHeight () {\n    return Math.max(\n      Math.max(doc.body.scrollHeight, doc.documentElement.scrollHeight),\n      Math.max(doc.body.offsetHeight, doc.documentElement.offsetHeight),\n      Math.max(doc.body.clientHeight, doc.documentElement.clientHeight)\n      );\n  }\n\n  function getCSSInt(element, attribute) {\n    var val = parseInt(getCSS(element, attribute), 10);\n    return (isNaN(val)) ? 0 : val; // borders in old IE are throwing \'medium\' for demo.html\n  }\n\n  function renderRect (ctx, x, y, w, h, bgcolor) {\n    if (bgcolor !== "transparent"){\n      ctx.setVariable("fillStyle", bgcolor);\n      ctx.fillRect(x, y, w, h);\n      numDraws+=1;\n    }\n  }\n\n  function capitalize(m, p1, p2) {\n    if (m.length > 0) {\n      return p1 + p2.toUpperCase();\n    }\n  }\n\n  function textTransform (text, transform) {\n    switch(transform){\n      case "lowercase":\n        return text.toLowerCase();\n      case "capitalize":\n        return text.replace( /(^|\\s|:|-|\\(|\\))([a-z])/g, capitalize);\n      case "uppercase":\n        return text.toUpperCase();\n      default:\n        return text;\n    }\n  }\n\n  function noLetterSpacing(letter_spacing) {\n    return (/^(normal|none|0px)$/.test(letter_spacing));\n  }\n\n  function drawText(currentText, x, y, ctx){\n    if (currentText !== null && Util.trimText(currentText).length > 0) {\n      ctx.fillText(currentText, x, y);\n      numDraws+=1;\n    }\n  }\n\n  function setTextVariables(ctx, el, text_decoration, color) {\n    var align = false,\n    bold = getCSS(el, "fontWeight"),\n    family = getCSS(el, "fontFamily"),\n    size = getCSS(el, "fontSize"),\n    shadows = Util.parseTextShadows(getCSS(el, "textShadow"));\n\n    switch(parseInt(bold, 10)){\n      case 401:\n        bold = "bold";\n        break;\n      case 400:\n        bold = "normal";\n        break;\n    }\n\n    ctx.setVariable("fillStyle", color);\n    ctx.setVariable("font", [getCSS(el, "fontStyle"), getCSS(el, "fontVariant"), bold, size, family].join(" "));\n    ctx.setVariable("textAlign", (align) ? "right" : "left");\n\n    if (shadows.length) {\n      // TODO: support multiple text shadows\n      // apply the first text shadow\n      ctx.setVariable("shadowColor", shadows[0].color);\n      ctx.setVariable("shadowOffsetX", shadows[0].offsetX);\n      ctx.setVariable("shadowOffsetY", shadows[0].offsetY);\n      ctx.setVariable("shadowBlur", shadows[0].blur);\n    }\n\n    if (text_decoration !== "none"){\n      return Util.Font(family, size, doc);\n    }\n  }\n\n  function renderTextDecoration(ctx, text_decoration, bounds, metrics, color) {\n    switch(text_decoration) {\n      case "underline":\n        // Draws a line at the baseline of the font\n        // TODO As some browsers display the line as more than 1px if the font-size is big, need to take that into account both in position and size\n        renderRect(ctx, bounds.left, Math.round(bounds.top + metrics.baseline + metrics.lineWidth), bounds.width, 1, color);\n        break;\n      case "overline":\n        renderRect(ctx, bounds.left, Math.round(bounds.top), bounds.width, 1, color);\n        break;\n      case "line-through":\n        // TODO try and find exact position for line-through\n        renderRect(ctx, bounds.left, Math.ceil(bounds.top + metrics.middle + metrics.lineWidth), bounds.width, 1, color);\n        break;\n    }\n  }\n\n  function getTextBounds(state, text, textDecoration, isLast, transform) {\n    var bounds;\n    if (support.rangeBounds && !transform) {\n      if (textDecoration !== "none" || Util.trimText(text).length !== 0) {\n        bounds = textRangeBounds(text, state.node, state.textOffset);\n      }\n      state.textOffset += text.length;\n    } else if (state.node && typeof state.node.nodeValue === "string" ){\n      var newTextNode = (isLast) ? state.node.splitText(text.length) : null;\n      bounds = textWrapperBounds(state.node, transform);\n      state.node = newTextNode;\n    }\n    return bounds;\n  }\n\n  function textRangeBounds(text, textNode, textOffset) {\n    var range = doc.createRange();\n    range.setStart(textNode, textOffset);\n    range.setEnd(textNode, textOffset + text.length);\n    return range.getBoundingClientRect();\n  }\n\n  function textWrapperBounds(oldTextNode, transform) {\n    var parent = oldTextNode.parentNode,\n    wrapElement = doc.createElement(\'wrapper\'),\n    backupText = oldTextNode.cloneNode(true);\n\n    wrapElement.appendChild(oldTextNode.cloneNode(true));\n    parent.replaceChild(wrapElement, oldTextNode);\n\n    var bounds = transform ? Util.OffsetBounds(wrapElement) : Util.Bounds(wrapElement);\n    parent.replaceChild(backupText, wrapElement);\n    return bounds;\n  }\n\n  function renderText(el, textNode, stack) {\n    var ctx = stack.ctx,\n    color = getCSS(el, "color"),\n    textDecoration = getCSS(el, "textDecoration"),\n    textAlign = getCSS(el, "textAlign"),\n    metrics,\n    textList,\n    state = {\n      node: textNode,\n      textOffset: 0\n    };\n\n    if (Util.trimText(textNode.nodeValue).length > 0) {\n      textNode.nodeValue = textTransform(textNode.nodeValue, getCSS(el, "textTransform"));\n      textAlign = textAlign.replace(["-webkit-auto"],["auto"]);\n\n      textList = (!options.letterRendering && /^(left|right|justify|auto)$/.test(textAlign) && noLetterSpacing(getCSS(el, "letterSpacing"))) ?\n      textNode.nodeValue.split(/(\\b| )/)\n      : textNode.nodeValue.split("");\n\n      metrics = setTextVariables(ctx, el, textDecoration, color);\n\n      if (options.chinese) {\n        textList.forEach(function(word, index) {\n          if (/.*[\\u4E00-\\u9FA5].*$/.test(word)) {\n            word = word.split("");\n            word.unshift(index, 1);\n            textList.splice.apply(textList, word);\n          }\n        });\n      }\n\n      textList.forEach(function(text, index) {\n        var bounds = getTextBounds(state, text, textDecoration, (index < textList.length - 1), stack.transform.matrix);\n        if (bounds) {\n          drawText(text, bounds.left, bounds.bottom, ctx);\n          renderTextDecoration(ctx, textDecoration, bounds, metrics, color);\n        }\n      });\n    }\n  }\n\n  function listPosition (element, val) {\n    var boundElement = doc.createElement( "boundelement" ),\n    originalType,\n    bounds;\n\n    boundElement.style.display = "inline";\n\n    originalType = element.style.listStyleType;\n    element.style.listStyleType = "none";\n\n    boundElement.appendChild(doc.createTextNode(val));\n\n    element.insertBefore(boundElement, element.firstChild);\n\n    bounds = Util.Bounds(boundElement);\n    element.removeChild(boundElement);\n    element.style.listStyleType = originalType;\n    return bounds;\n  }\n\n  function elementIndex(el) {\n    var i = -1,\n    count = 1,\n    childs = el.parentNode.childNodes;\n\n    if (el.parentNode) {\n      while(childs[++i] !== el) {\n        if (childs[i].nodeType === 1) {\n          count++;\n        }\n      }\n      return count;\n    } else {\n      return -1;\n    }\n  }\n\n  function listItemText(element, type) {\n    var currentIndex = elementIndex(element), text;\n    switch(type){\n      case "decimal":\n        text = currentIndex;\n        break;\n      case "decimal-leading-zero":\n        text = (currentIndex.toString().length === 1) ? currentIndex = "0" + currentIndex.toString() : currentIndex.toString();\n        break;\n      case "upper-roman":\n        text = _html2canvas.Generate.ListRoman( currentIndex );\n        break;\n      case "lower-roman":\n        text = _html2canvas.Generate.ListRoman( currentIndex ).toLowerCase();\n        break;\n      case "lower-alpha":\n        text = _html2canvas.Generate.ListAlpha( currentIndex ).toLowerCase();\n        break;\n      case "upper-alpha":\n        text = _html2canvas.Generate.ListAlpha( currentIndex );\n        break;\n    }\n\n    return text + ". ";\n  }\n\n  function renderListItem(element, stack, elBounds) {\n    var x,\n    text,\n    ctx = stack.ctx,\n    type = getCSS(element, "listStyleType"),\n    listBounds;\n\n    if (/^(decimal|decimal-leading-zero|upper-alpha|upper-latin|upper-roman|lower-alpha|lower-greek|lower-latin|lower-roman)$/i.test(type)) {\n      text = listItemText(element, type);\n      listBounds = listPosition(element, text);\n      setTextVariables(ctx, element, "none", getCSS(element, "color"));\n\n      if (getCSS(element, "listStylePosition") === "inside") {\n        ctx.setVariable("textAlign", "left");\n        x = elBounds.left;\n      } else {\n        return;\n      }\n\n      drawText(text, x, listBounds.bottom, ctx);\n    }\n  }\n\n  function loadImage (src){\n    var img = images[src];\n    return (img && img.succeeded === true) ? img.img : false;\n  }\n\n  function clipBounds(src, dst){\n    var x = Math.max(src.left, dst.left),\n    y = Math.max(src.top, dst.top),\n    x2 = Math.min((src.left + src.width), (dst.left + dst.width)),\n    y2 = Math.min((src.top + src.height), (dst.top + dst.height));\n\n    return {\n      left:x,\n      top:y,\n      width:x2-x,\n      height:y2-y\n    };\n  }\n\n  function setZ(element, stack, parentStack){\n    var newContext,\n    isPositioned = stack.cssPosition !== \'static\',\n    zIndex = isPositioned ? getCSS(element, \'zIndex\') : \'auto\',\n    opacity = getCSS(element, \'opacity\'),\n    isFloated = getCSS(element, \'cssFloat\') !== \'none\';\n\n    // https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Understanding_z_index/The_stacking_context\n    // When a new stacking context should be created:\n    // the root element (HTML),\n    // positioned (absolutely or relatively) with a z-index value other than "auto",\n    // elements with an opacity value less than 1. (See the specification for opacity),\n    // on mobile WebKit and Chrome 22+, position: fixed always creates a new stacking context, even when z-index is "auto" (See this post)\n\n    stack.zIndex = newContext = h2czContext(zIndex);\n    newContext.isPositioned = isPositioned;\n    newContext.isFloated = isFloated;\n    newContext.opacity = opacity;\n    newContext.ownStacking = (zIndex !== \'auto\' || opacity < 1);\n\n    if (parentStack) {\n      parentStack.zIndex.children.push(stack);\n    }\n  }\n\n  function renderImage(ctx, element, image, bounds, borders) {\n\n    var paddingLeft = getCSSInt(element, \'paddingLeft\'),\n    paddingTop = getCSSInt(element, \'paddingTop\'),\n    paddingRight = getCSSInt(element, \'paddingRight\'),\n    paddingBottom = getCSSInt(element, \'paddingBottom\');\n\n    drawImage(\n      ctx,\n      image,\n      0, //sx\n      0, //sy\n      image.width, //sw\n      image.height, //sh\n      bounds.left + paddingLeft + borders[3].width, //dx\n      bounds.top + paddingTop + borders[0].width, // dy\n      bounds.width - (borders[1].width + borders[3].width + paddingLeft + paddingRight), //dw\n      bounds.height - (borders[0].width + borders[2].width + paddingTop + paddingBottom) //dh\n      );\n  }\n\n  function getBorderData(element) {\n    return ["Top", "Right", "Bottom", "Left"].map(function(side) {\n      return {\n        width: getCSSInt(element, \'border\' + side + \'Width\'),\n        color: getCSS(element, \'border\' + side + \'Color\')\n      };\n    });\n  }\n\n  function getBorderRadiusData(element) {\n    return ["TopLeft", "TopRight", "BottomRight", "BottomLeft"].map(function(side) {\n      return getCSS(element, \'border\' + side + \'Radius\');\n    });\n  }\n\n  var getCurvePoints = (function(kappa) {\n\n    return function(x, y, r1, r2) {\n      var ox = (r1) * kappa, // control point offset horizontal\n      oy = (r2) * kappa, // control point offset vertical\n      xm = x + r1, // x-middle\n      ym = y + r2; // y-middle\n      return {\n        topLeft: bezierCurve({\n          x:x,\n          y:ym\n        }, {\n          x:x,\n          y:ym - oy\n        }, {\n          x:xm - ox,\n          y:y\n        }, {\n          x:xm,\n          y:y\n        }),\n        topRight: bezierCurve({\n          x:x,\n          y:y\n        }, {\n          x:x + ox,\n          y:y\n        }, {\n          x:xm,\n          y:ym - oy\n        }, {\n          x:xm,\n          y:ym\n        }),\n        bottomRight: bezierCurve({\n          x:xm,\n          y:y\n        }, {\n          x:xm,\n          y:y + oy\n        }, {\n          x:x + ox,\n          y:ym\n        }, {\n          x:x,\n          y:ym\n        }),\n        bottomLeft: bezierCurve({\n          x:xm,\n          y:ym\n        }, {\n          x:xm - ox,\n          y:ym\n        }, {\n          x:x,\n          y:y + oy\n        }, {\n          x:x,\n          y:y\n        })\n      };\n    };\n  })(4 * ((Math.sqrt(2) - 1) / 3));\n\n  function bezierCurve(start, startControl, endControl, end) {\n\n    var lerp = function (a, b, t) {\n      return {\n        x:a.x + (b.x - a.x) * t,\n        y:a.y + (b.y - a.y) * t\n      };\n    };\n\n    return {\n      start: start,\n      startControl: startControl,\n      endControl: endControl,\n      end: end,\n      subdivide: function(t) {\n        var ab = lerp(start, startControl, t),\n        bc = lerp(startControl, endControl, t),\n        cd = lerp(endControl, end, t),\n        abbc = lerp(ab, bc, t),\n        bccd = lerp(bc, cd, t),\n        dest = lerp(abbc, bccd, t);\n        return [bezierCurve(start, ab, abbc, dest), bezierCurve(dest, bccd, cd, end)];\n      },\n      curveTo: function(borderArgs) {\n        borderArgs.push(["bezierCurve", startControl.x, startControl.y, endControl.x, endControl.y, end.x, end.y]);\n      },\n      curveToReversed: function(borderArgs) {\n        borderArgs.push(["bezierCurve", endControl.x, endControl.y, startControl.x, startControl.y, start.x, start.y]);\n      }\n    };\n  }\n\n  function parseCorner(borderArgs, radius1, radius2, corner1, corner2, x, y) {\n    if (radius1[0] > 0 || radius1[1] > 0) {\n      borderArgs.push(["line", corner1[0].start.x, corner1[0].start.y]);\n      corner1[0].curveTo(borderArgs);\n      corner1[1].curveTo(borderArgs);\n    } else {\n      borderArgs.push(["line", x, y]);\n    }\n\n    if (radius2[0] > 0 || radius2[1] > 0) {\n      borderArgs.push(["line", corner2[0].start.x, corner2[0].start.y]);\n    }\n  }\n\n  function drawSide(borderData, radius1, radius2, outer1, inner1, outer2, inner2) {\n    var borderArgs = [];\n\n    if (radius1[0] > 0 || radius1[1] > 0) {\n      borderArgs.push(["line", outer1[1].start.x, outer1[1].start.y]);\n      outer1[1].curveTo(borderArgs);\n    } else {\n      borderArgs.push([ "line", borderData.c1[0], borderData.c1[1]]);\n    }\n\n    if (radius2[0] > 0 || radius2[1] > 0) {\n      borderArgs.push(["line", outer2[0].start.x, outer2[0].start.y]);\n      outer2[0].curveTo(borderArgs);\n      borderArgs.push(["line", inner2[0].end.x, inner2[0].end.y]);\n      inner2[0].curveToReversed(borderArgs);\n    } else {\n      borderArgs.push([ "line", borderData.c2[0], borderData.c2[1]]);\n      borderArgs.push([ "line", borderData.c3[0], borderData.c3[1]]);\n    }\n\n    if (radius1[0] > 0 || radius1[1] > 0) {\n      borderArgs.push(["line", inner1[1].end.x, inner1[1].end.y]);\n      inner1[1].curveToReversed(borderArgs);\n    } else {\n      borderArgs.push([ "line", borderData.c4[0], borderData.c4[1]]);\n    }\n\n    return borderArgs;\n  }\n\n  function calculateCurvePoints(bounds, borderRadius, borders) {\n\n    var x = bounds.left,\n    y = bounds.top,\n    width = bounds.width,\n    height = bounds.height,\n\n    tlh = borderRadius[0][0],\n    tlv = borderRadius[0][1],\n    trh = borderRadius[1][0],\n    trv = borderRadius[1][1],\n    brh = borderRadius[2][0],\n    brv = borderRadius[2][1],\n    blh = borderRadius[3][0],\n    blv = borderRadius[3][1],\n\n    topWidth = width - trh,\n    rightHeight = height - brv,\n    bottomWidth = width - brh,\n    leftHeight = height - blv;\n\n    return {\n      topLeftOuter: getCurvePoints(\n        x,\n        y,\n        tlh,\n        tlv\n        ).topLeft.subdivide(0.5),\n\n      topLeftInner: getCurvePoints(\n        x + borders[3].width,\n        y + borders[0].width,\n        Math.max(0, tlh - borders[3].width),\n        Math.max(0, tlv - borders[0].width)\n        ).topLeft.subdivide(0.5),\n\n      topRightOuter: getCurvePoints(\n        x + topWidth,\n        y,\n        trh,\n        trv\n        ).topRight.subdivide(0.5),\n\n      topRightInner: getCurvePoints(\n        x + Math.min(topWidth, width + borders[3].width),\n        y + borders[0].width,\n        (topWidth > width + borders[3].width) ? 0 :trh - borders[3].width,\n        trv - borders[0].width\n        ).topRight.subdivide(0.5),\n\n      bottomRightOuter: getCurvePoints(\n        x + bottomWidth,\n        y + rightHeight,\n        brh,\n        brv\n        ).bottomRight.subdivide(0.5),\n\n      bottomRightInner: getCurvePoints(\n        x + Math.min(bottomWidth, width + borders[3].width),\n        y + Math.min(rightHeight, height + borders[0].width),\n        Math.max(0, brh - borders[1].width),\n        Math.max(0, brv - borders[2].width)\n        ).bottomRight.subdivide(0.5),\n\n      bottomLeftOuter: getCurvePoints(\n        x,\n        y + leftHeight,\n        blh,\n        blv\n        ).bottomLeft.subdivide(0.5),\n\n      bottomLeftInner: getCurvePoints(\n        x + borders[3].width,\n        y + leftHeight,\n        Math.max(0, blh - borders[3].width),\n        Math.max(0, blv - borders[2].width)\n        ).bottomLeft.subdivide(0.5)\n    };\n  }\n\n  function getBorderClip(element, borderPoints, borders, radius, bounds) {\n    var backgroundClip = getCSS(element, \'backgroundClip\'),\n    borderArgs = [];\n\n    switch(backgroundClip) {\n      case "content-box":\n      case "padding-box":\n        parseCorner(borderArgs, radius[0], radius[1], borderPoints.topLeftInner, borderPoints.topRightInner, bounds.left + borders[3].width, bounds.top + borders[0].width);\n        parseCorner(borderArgs, radius[1], radius[2], borderPoints.topRightInner, borderPoints.bottomRightInner, bounds.left + bounds.width - borders[1].width, bounds.top + borders[0].width);\n        parseCorner(borderArgs, radius[2], radius[3], borderPoints.bottomRightInner, borderPoints.bottomLeftInner, bounds.left + bounds.width - borders[1].width, bounds.top + bounds.height - borders[2].width);\n        parseCorner(borderArgs, radius[3], radius[0], borderPoints.bottomLeftInner, borderPoints.topLeftInner, bounds.left + borders[3].width, bounds.top + bounds.height - borders[2].width);\n        break;\n\n      default:\n        parseCorner(borderArgs, radius[0], radius[1], borderPoints.topLeftOuter, borderPoints.topRightOuter, bounds.left, bounds.top);\n        parseCorner(borderArgs, radius[1], radius[2], borderPoints.topRightOuter, borderPoints.bottomRightOuter, bounds.left + bounds.width, bounds.top);\n        parseCorner(borderArgs, radius[2], radius[3], borderPoints.bottomRightOuter, borderPoints.bottomLeftOuter, bounds.left + bounds.width, bounds.top + bounds.height);\n        parseCorner(borderArgs, radius[3], radius[0], borderPoints.bottomLeftOuter, borderPoints.topLeftOuter, bounds.left, bounds.top + bounds.height);\n        break;\n    }\n\n    return borderArgs;\n  }\n\n  function parseBorders(element, bounds, borders){\n    var x = bounds.left,\n    y = bounds.top,\n    width = bounds.width,\n    height = bounds.height,\n    borderSide,\n    bx,\n    by,\n    bw,\n    bh,\n    borderArgs,\n    // http://www.w3.org/TR/css3-background/#the-border-radius\n    borderRadius = getBorderRadiusData(element),\n    borderPoints = calculateCurvePoints(bounds, borderRadius, borders),\n    borderData = {\n      clip: getBorderClip(element, borderPoints, borders, borderRadius, bounds),\n      borders: []\n    };\n\n    for (borderSide = 0; borderSide < 4; borderSide++) {\n\n      if (borders[borderSide].width > 0) {\n        bx = x;\n        by = y;\n        bw = width;\n        bh = height - (borders[2].width);\n\n        switch(borderSide) {\n          case 0:\n            // top border\n            bh = borders[0].width;\n\n            borderArgs = drawSide({\n              c1: [bx, by],\n              c2: [bx + bw, by],\n              c3: [bx + bw - borders[1].width, by + bh],\n              c4: [bx + borders[3].width, by + bh]\n            }, borderRadius[0], borderRadius[1],\n            borderPoints.topLeftOuter, borderPoints.topLeftInner, borderPoints.topRightOuter, borderPoints.topRightInner);\n            break;\n          case 1:\n            // right border\n            bx = x + width - (borders[1].width);\n            bw = borders[1].width;\n\n            borderArgs = drawSide({\n              c1: [bx + bw, by],\n              c2: [bx + bw, by + bh + borders[2].width],\n              c3: [bx, by + bh],\n              c4: [bx, by + borders[0].width]\n            }, borderRadius[1], borderRadius[2],\n            borderPoints.topRightOuter, borderPoints.topRightInner, borderPoints.bottomRightOuter, borderPoints.bottomRightInner);\n            break;\n          case 2:\n            // bottom border\n            by = (by + height) - (borders[2].width);\n            bh = borders[2].width;\n\n            borderArgs = drawSide({\n              c1: [bx + bw, by + bh],\n              c2: [bx, by + bh],\n              c3: [bx + borders[3].width, by],\n              c4: [bx + bw - borders[3].width, by]\n            }, borderRadius[2], borderRadius[3],\n            borderPoints.bottomRightOuter, borderPoints.bottomRightInner, borderPoints.bottomLeftOuter, borderPoints.bottomLeftInner);\n            break;\n          case 3:\n            // left border\n            bw = borders[3].width;\n\n            borderArgs = drawSide({\n              c1: [bx, by + bh + borders[2].width],\n              c2: [bx, by],\n              c3: [bx + bw, by + borders[0].width],\n              c4: [bx + bw, by + bh]\n            }, borderRadius[3], borderRadius[0],\n            borderPoints.bottomLeftOuter, borderPoints.bottomLeftInner, borderPoints.topLeftOuter, borderPoints.topLeftInner);\n            break;\n        }\n\n        borderData.borders.push({\n          args: borderArgs,\n          color: borders[borderSide].color\n        });\n\n      }\n    }\n\n    return borderData;\n  }\n\n  function createShape(ctx, args) {\n    var shape = ctx.drawShape();\n    args.forEach(function(border, index) {\n      shape[(index === 0) ? "moveTo" : border[0] + "To" ].apply(null, border.slice(1));\n    });\n    return shape;\n  }\n\n  function renderBorders(ctx, borderArgs, color) {\n    if (color !== "transparent") {\n      ctx.setVariable( "fillStyle", color);\n      createShape(ctx, borderArgs);\n      ctx.fill();\n      numDraws+=1;\n    }\n  }\n\n  function renderFormValue (el, bounds, stack){\n\n    var valueWrap = doc.createElement(\'valuewrap\'),\n    cssPropertyArray = [\'lineHeight\',\'textAlign\',\'fontFamily\',\'color\',\'fontSize\',\'paddingLeft\',\'paddingTop\',\'width\',\'height\',\'border\',\'borderLeftWidth\',\'borderTopWidth\'],\n    textValue,\n    textNode;\n\n    cssPropertyArray.forEach(function(property) {\n      try {\n        valueWrap.style[property] = getCSS(el, property);\n      } catch(e) {\n        // Older IE has issues with "border"\n        Util.log("html2canvas: Parse: Exception caught in renderFormValue: " + e.message);\n      }\n    });\n\n    valueWrap.style.borderColor = "black";\n    valueWrap.style.borderStyle = "solid";\n    valueWrap.style.display = "block";\n    valueWrap.style.position = "absolute";\n\n    if (/^(submit|reset|button|text|password)$/.test(el.type) || el.nodeName === "SELECT"){\n      valueWrap.style.lineHeight = getCSS(el, "height");\n    }\n\n    valueWrap.style.top = bounds.top + "px";\n    valueWrap.style.left = bounds.left + "px";\n\n    textValue = (el.nodeName === "SELECT") ? (el.options[el.selectedIndex] || 0).text : el.value;\n    if(!textValue) {\n      textValue = el.placeholder;\n    }\n\n    textNode = doc.createTextNode(textValue);\n\n    valueWrap.appendChild(textNode);\n    body.appendChild(valueWrap);\n\n    renderText(el, textNode, stack);\n    body.removeChild(valueWrap);\n  }\n\n  function drawImage (ctx) {\n    ctx.drawImage.apply(ctx, Array.prototype.slice.call(arguments, 1));\n    numDraws+=1;\n  }\n\n  function getPseudoElement(el, which) {\n    var elStyle = window.getComputedStyle(el, which);\n    if(!elStyle || !elStyle.content || elStyle.content === "none" || elStyle.content === "-moz-alt-content" || elStyle.display === "none") {\n      return;\n    }\n    var content = elStyle.content + \'\',\n    first = content.substr( 0, 1 );\n    //strips quotes\n    if(first === content.substr( content.length - 1 ) && first.match(/\'|"/)) {\n      content = content.substr( 1, content.length - 2 );\n    }\n\n    var isImage = content.substr( 0, 3 ) === \'url\',\n    elps = document.createElement( isImage ? \'img\' : \'span\' );\n\n    elps.className = pseudoHide + "-before " + pseudoHide + "-after";\n\n    Object.keys(elStyle).filter(indexedProperty).forEach(function(prop) {\n      // Prevent assigning of read only CSS Rules, ex. length, parentRule\n      try {\n        elps.style[prop] = elStyle[prop];\n      } catch (e) {\n        Util.log([\'Tried to assign readonly property \', prop, \'Error:\', e]);\n      }\n    });\n\n    if(isImage) {\n      elps.src = Util.parseBackgroundImage(content)[0].args[0];\n    } else {\n      elps.innerHTML = content;\n    }\n    return elps;\n  }\n\n  function indexedProperty(property) {\n    return (isNaN(window.parseInt(property, 10)));\n  }\n\n  function injectPseudoElements(el, stack) {\n    var before = getPseudoElement(el, \':before\'),\n    after = getPseudoElement(el, \':after\');\n    if(!before && !after) {\n      return;\n    }\n\n    if(before) {\n      el.className += " " + pseudoHide + "-before";\n      el.parentNode.insertBefore(before, el);\n      parseElement(before, stack, true);\n      el.parentNode.removeChild(before);\n      el.className = el.className.replace(pseudoHide + "-before", "").trim();\n    }\n\n    if (after) {\n      el.className += " " + pseudoHide + "-after";\n      el.appendChild(after);\n      parseElement(after, stack, true);\n      el.removeChild(after);\n      el.className = el.className.replace(pseudoHide + "-after", "").trim();\n    }\n\n  }\n\n  function renderBackgroundRepeat(ctx, image, backgroundPosition, bounds) {\n    var offsetX = Math.round(bounds.left + backgroundPosition.left),\n    offsetY = Math.round(bounds.top + backgroundPosition.top);\n\n    ctx.createPattern(image);\n    ctx.translate(offsetX, offsetY);\n    ctx.fill();\n    ctx.translate(-offsetX, -offsetY);\n  }\n\n  function backgroundRepeatShape(ctx, image, backgroundPosition, bounds, left, top, width, height) {\n    var args = [];\n    args.push(["line", Math.round(left), Math.round(top)]);\n    args.push(["line", Math.round(left + width), Math.round(top)]);\n    args.push(["line", Math.round(left + width), Math.round(height + top)]);\n    args.push(["line", Math.round(left), Math.round(height + top)]);\n    createShape(ctx, args);\n    ctx.save();\n    ctx.clip();\n    renderBackgroundRepeat(ctx, image, backgroundPosition, bounds);\n    ctx.restore();\n  }\n\n  function renderBackgroundColor(ctx, backgroundBounds, bgcolor) {\n    renderRect(\n      ctx,\n      backgroundBounds.left,\n      backgroundBounds.top,\n      backgroundBounds.width,\n      backgroundBounds.height,\n      bgcolor\n      );\n  }\n\n  function renderBackgroundRepeating(el, bounds, ctx, image, imageIndex) {\n    var backgroundSize = Util.BackgroundSize(el, bounds, image, imageIndex),\n    backgroundPosition = Util.BackgroundPosition(el, bounds, image, imageIndex, backgroundSize),\n    backgroundRepeat = getCSS(el, "backgroundRepeat").split(",").map(Util.trimText);\n\n    image = resizeImage(image, backgroundSize);\n\n    backgroundRepeat = backgroundRepeat[imageIndex] || backgroundRepeat[0];\n\n    switch (backgroundRepeat) {\n      case "repeat-x":\n        backgroundRepeatShape(ctx, image, backgroundPosition, bounds,\n          bounds.left, bounds.top + backgroundPosition.top, 99999, image.height);\n        break;\n\n      case "repeat-y":\n        backgroundRepeatShape(ctx, image, backgroundPosition, bounds,\n          bounds.left + backgroundPosition.left, bounds.top, image.width, 99999);\n        break;\n\n      case "no-repeat":\n        backgroundRepeatShape(ctx, image, backgroundPosition, bounds,\n          bounds.left + backgroundPosition.left, bounds.top + backgroundPosition.top, image.width, image.height);\n        break;\n\n      default:\n        renderBackgroundRepeat(ctx, image, backgroundPosition, {\n          top: bounds.top,\n          left: bounds.left,\n          width: image.width,\n          height: image.height\n        });\n        break;\n    }\n  }\n\n  function renderBackgroundImage(element, bounds, ctx) {\n    var backgroundImage = getCSS(element, "backgroundImage"),\n    backgroundImages = Util.parseBackgroundImage(backgroundImage),\n    image,\n    imageIndex = backgroundImages.length;\n\n    while(imageIndex--) {\n      backgroundImage = backgroundImages[imageIndex];\n\n      if (!backgroundImage.args || backgroundImage.args.length === 0) {\n        continue;\n      }\n\n      var key = backgroundImage.method === \'url\' ?\n      backgroundImage.args[0] :\n      backgroundImage.value;\n\n      image = loadImage(key);\n\n      // TODO add support for background-origin\n      if (image) {\n        renderBackgroundRepeating(element, bounds, ctx, image, imageIndex);\n      } else {\n        Util.log("html2canvas: Error loading background:", backgroundImage);\n      }\n    }\n  }\n\n  function resizeImage(image, bounds) {\n    if(image.width === bounds.width && image.height === bounds.height) {\n      return image;\n    }\n\n    var ctx, canvas = doc.createElement(\'canvas\');\n    canvas.width = bounds.width;\n    canvas.height = bounds.height;\n    ctx = canvas.getContext("2d");\n    drawImage(ctx, image, 0, 0, image.width, image.height, 0, 0, bounds.width, bounds.height );\n    return canvas;\n  }\n\n  function setOpacity(ctx, element, parentStack) {\n    return ctx.setVariable("globalAlpha", getCSS(element, "opacity") * ((parentStack) ? parentStack.opacity : 1));\n  }\n\n  function removePx(str) {\n    return str.replace("px", "");\n  }\n\n  var transformRegExp = /(matrix)\\((.+)\\)/;\n\n  function getTransform(element, parentStack) {\n    var transform = getCSS(element, "transform") || getCSS(element, "-webkit-transform") || getCSS(element, "-moz-transform") || getCSS(element, "-ms-transform") || getCSS(element, "-o-transform");\n    var transformOrigin = getCSS(element, "transform-origin") || getCSS(element, "-webkit-transform-origin") || getCSS(element, "-moz-transform-origin") || getCSS(element, "-ms-transform-origin") || getCSS(element, "-o-transform-origin") || "0px 0px";\n\n    transformOrigin = transformOrigin.split(" ").map(removePx).map(Util.asFloat);\n\n    var matrix;\n    if (transform && transform !== "none") {\n      var match = transform.match(transformRegExp);\n      if (match) {\n        switch(match[1]) {\n          case "matrix":\n            matrix = match[2].split(",").map(Util.trimText).map(Util.asFloat);\n            break;\n        }\n      }\n    }\n\n    return {\n      origin: transformOrigin,\n      matrix: matrix\n    };\n  }\n\n  function createStack(element, parentStack, bounds, transform) {\n    var ctx = h2cRenderContext((!parentStack) ? documentWidth() : bounds.width , (!parentStack) ? documentHeight() : bounds.height),\n    stack = {\n      ctx: ctx,\n      opacity: setOpacity(ctx, element, parentStack),\n      cssPosition: getCSS(element, "position"),\n      borders: getBorderData(element),\n      transform: transform,\n      clip: (parentStack && parentStack.clip) ? Util.Extend( {}, parentStack.clip ) : null\n    };\n\n    setZ(element, stack, parentStack);\n\n    // TODO correct overflow for absolute content residing under a static position\n    if (options.useOverflow === true && /(hidden|scroll|auto)/.test(getCSS(element, "overflow")) === true && /(BODY)/i.test(element.nodeName) === false){\n      stack.clip = (stack.clip) ? clipBounds(stack.clip, bounds) : bounds;\n    }\n\n    return stack;\n  }\n\n  function getBackgroundBounds(borders, bounds, clip) {\n    var backgroundBounds = {\n      left: bounds.left + borders[3].width,\n      top: bounds.top + borders[0].width,\n      width: bounds.width - (borders[1].width + borders[3].width),\n      height: bounds.height - (borders[0].width + borders[2].width)\n    };\n\n    if (clip) {\n      backgroundBounds = clipBounds(backgroundBounds, clip);\n    }\n\n    return backgroundBounds;\n  }\n\n  function getBounds(element, transform) {\n    var bounds = (transform.matrix) ? Util.OffsetBounds(element) : Util.Bounds(element);\n    transform.origin[0] += bounds.left;\n    transform.origin[1] += bounds.top;\n    return bounds;\n  }\n\n  function renderElement(element, parentStack, pseudoElement, ignoreBackground) {\n    var transform = getTransform(element, parentStack),\n    bounds = getBounds(element, transform),\n    image,\n    stack = createStack(element, parentStack, bounds, transform),\n    borders = stack.borders,\n    ctx = stack.ctx,\n    backgroundBounds = getBackgroundBounds(borders, bounds, stack.clip),\n    borderData = parseBorders(element, bounds, borders),\n    backgroundColor = (ignoreElementsRegExp.test(element.nodeName)) ? "#efefef" : getCSS(element, "backgroundColor");\n\n\n    createShape(ctx, borderData.clip);\n\n    ctx.save();\n    ctx.clip();\n\n    if (backgroundBounds.height > 0 && backgroundBounds.width > 0 && !ignoreBackground) {\n      renderBackgroundColor(ctx, bounds, backgroundColor);\n      renderBackgroundImage(element, backgroundBounds, ctx);\n    } else if (ignoreBackground) {\n      stack.backgroundColor =  backgroundColor;\n    }\n\n    ctx.restore();\n\n    borderData.borders.forEach(function(border) {\n      renderBorders(ctx, border.args, border.color);\n    });\n\n    if (!pseudoElement) {\n      injectPseudoElements(element, stack);\n    }\n\n    switch(element.nodeName){\n      case "IMG":\n        if ((image = loadImage(element.getAttribute(\'src\')))) {\n          renderImage(ctx, element, image, bounds, borders);\n        } else {\n          Util.log("html2canvas: Error loading <img>:" + element.getAttribute(\'src\'));\n        }\n        break;\n      case "INPUT":\n        // TODO add all relevant type\'s, i.e. HTML5 new stuff\n        // todo add support for placeholder attribute for browsers which support it\n        if (/^(text|url|email|submit|button|reset)$/.test(element.type) && (element.value || element.placeholder || "").length > 0){\n          renderFormValue(element, bounds, stack);\n        }\n        break;\n      case "TEXTAREA":\n        if ((element.value || element.placeholder || "").length > 0){\n          renderFormValue(element, bounds, stack);\n        }\n        break;\n      case "SELECT":\n        if ((element.options||element.placeholder || "").length > 0){\n          renderFormValue(element, bounds, stack);\n        }\n        break;\n      case "LI":\n        renderListItem(element, stack, backgroundBounds);\n        break;\n      case "CANVAS":\n        renderImage(ctx, element, element, bounds, borders);\n        break;\n    }\n\n    return stack;\n  }\n\n  function isElementVisible(element) {\n    return (getCSS(element, \'display\') !== "none" && getCSS(element, \'visibility\') !== "hidden" && !element.hasAttribute("data-html2canvas-ignore"));\n  }\n\n  function parseElement (element, stack, pseudoElement) {\n    if (isElementVisible(element)) {\n      stack = renderElement(element, stack, pseudoElement, false) || stack;\n      if (!ignoreElementsRegExp.test(element.nodeName)) {\n        parseChildren(element, stack, pseudoElement);\n      }\n    }\n  }\n\n  function parseChildren(element, stack, pseudoElement) {\n    Util.Children(element).forEach(function(node) {\n      if (node.nodeType === node.ELEMENT_NODE) {\n        parseElement(node, stack, pseudoElement);\n      } else if (node.nodeType === node.TEXT_NODE) {\n        renderText(element, node, stack);\n      }\n    });\n  }\n\n  function init() {\n    var background = getCSS(document.documentElement, "backgroundColor"),\n      transparentBackground = (Util.isTransparent(background) && element === document.body),\n      stack = renderElement(element, null, false, transparentBackground);\n    parseChildren(element, stack);\n\n    if (transparentBackground) {\n      background = stack.backgroundColor;\n    }\n\n    body.removeChild(hidePseudoElements);\n    return {\n      backgroundColor: background,\n      stack: stack\n    };\n  }\n\n  return init();\n};\n\nfunction h2czContext(zindex) {\n  return {\n    zindex: zindex,\n    children: []\n  };\n}\n\n_html2canvas.Preload = function( options ) {\n\n  var images = {\n    numLoaded: 0,   // also failed are counted here\n    numFailed: 0,\n    numTotal: 0,\n    cleanupDone: false\n  },\n  pageOrigin,\n  Util = _html2canvas.Util,\n  methods,\n  i,\n  count = 0,\n  element = options.elements[0] || document.body,\n  doc = element.ownerDocument,\n  domImages = element.getElementsByTagName(\'img\'), // Fetch images of the present element only\n  imgLen = domImages.length,\n  link = doc.createElement("a"),\n  supportCORS = (function( img ){\n    return (img.crossOrigin !== undefined);\n  })(new Image()),\n  timeoutTimer;\n\n  link.href = window.location.href;\n  pageOrigin  = link.protocol + link.host;\n\n  function isSameOrigin(url){\n    link.href = url;\n    link.href = link.href; // YES, BELIEVE IT OR NOT, that is required for IE9 - http://jsfiddle.net/niklasvh/2e48b/\n    var origin = link.protocol + link.host;\n    return (origin === pageOrigin);\n  }\n\n  function start(){\n    Util.log("html2canvas: start: images: " + images.numLoaded + " / " + images.numTotal + " (failed: " + images.numFailed + ")");\n    if (!images.firstRun && images.numLoaded >= images.numTotal){\n      Util.log("Finished loading images: # " + images.numTotal + " (failed: " + images.numFailed + ")");\n\n      if (typeof options.complete === "function"){\n        options.complete(images);\n      }\n\n    }\n  }\n\n  // TODO modify proxy to serve images with CORS enabled, where available\n  function proxyGetImage(url, img, imageObj){\n    var callback_name,\n    scriptUrl = options.proxy,\n    script;\n\n    link.href = url;\n    url = link.href; // work around for pages with base href="" set - WARNING: this may change the url\n\n    callback_name = \'html2canvas_\' + (count++);\n    imageObj.callbackname = callback_name;\n\n    if (scriptUrl.indexOf("?") > -1) {\n      scriptUrl += "&";\n    } else {\n      scriptUrl += "?";\n    }\n    scriptUrl += \'url=\' + encodeURIComponent(url) + \'&callback=\' + callback_name;\n    script = doc.createElement("script");\n\n    window[callback_name] = function(a){\n      if (a.substring(0,6) === "error:"){\n        imageObj.succeeded = false;\n        images.numLoaded++;\n        images.numFailed++;\n        start();\n      } else {\n        setImageLoadHandlers(img, imageObj);\n        img.src = a;\n      }\n      window[callback_name] = undefined; // to work with IE<9  // NOTE: that the undefined callback property-name still exists on the window object (for IE<9)\n      try {\n        delete window[callback_name];  // for all browser that support this\n      } catch(ex) {}\n      script.parentNode.removeChild(script);\n      script = null;\n      delete imageObj.script;\n      delete imageObj.callbackname;\n    };\n\n    script.setAttribute("type", "text/javascript");\n    script.setAttribute("src", scriptUrl);\n    imageObj.script = script;\n    window.document.body.appendChild(script);\n\n  }\n\n  function loadPseudoElement(element, type) {\n    var style = window.getComputedStyle(element, type),\n    content = style.content;\n    if (content.substr(0, 3) === \'url\') {\n      methods.loadImage(_html2canvas.Util.parseBackgroundImage(content)[0].args[0]);\n    }\n    loadBackgroundImages(style.backgroundImage, element);\n  }\n\n  function loadPseudoElementImages(element) {\n    loadPseudoElement(element, ":before");\n    loadPseudoElement(element, ":after");\n  }\n\n  function loadGradientImage(backgroundImage, bounds) {\n    var img = _html2canvas.Generate.Gradient(backgroundImage, bounds);\n\n    if (img !== undefined){\n      images[backgroundImage] = {\n        img: img,\n        succeeded: true\n      };\n      images.numTotal++;\n      images.numLoaded++;\n      start();\n    }\n  }\n\n  function invalidBackgrounds(background_image) {\n    return (background_image && background_image.method && background_image.args && background_image.args.length > 0 );\n  }\n\n  function loadBackgroundImages(background_image, el) {\n    var bounds;\n\n    _html2canvas.Util.parseBackgroundImage(background_image).filter(invalidBackgrounds).forEach(function(background_image) {\n      if (background_image.method === \'url\') {\n        methods.loadImage(background_image.args[0]);\n      } else if(background_image.method.match(/\\-?gradient$/)) {\n        if(bounds === undefined) {\n          bounds = _html2canvas.Util.Bounds(el);\n        }\n        loadGradientImage(background_image.value, bounds);\n      }\n    });\n  }\n\n  function getImages (el) {\n    var elNodeType = false;\n\n    // Firefox fails with permission denied on pages with iframes\n    try {\n      Util.Children(el).forEach(getImages);\n    }\n    catch( e ) {}\n\n    try {\n      elNodeType = el.nodeType;\n    } catch (ex) {\n      elNodeType = false;\n      Util.log("html2canvas: failed to access some element\'s nodeType - Exception: " + ex.message);\n    }\n\n    if (elNodeType === 1 || elNodeType === undefined) {\n      loadPseudoElementImages(el);\n      try {\n        loadBackgroundImages(Util.getCSS(el, \'backgroundImage\'), el);\n      } catch(e) {\n        Util.log("html2canvas: failed to get background-image - Exception: " + e.message);\n      }\n      loadBackgroundImages(el);\n    }\n  }\n\n  function setImageLoadHandlers(img, imageObj) {\n    img.onload = function() {\n      if ( imageObj.timer !== undefined ) {\n        // CORS succeeded\n        window.clearTimeout( imageObj.timer );\n      }\n\n      images.numLoaded++;\n      imageObj.succeeded = true;\n      img.onerror = img.onload = null;\n      start();\n    };\n    img.onerror = function() {\n      if (img.crossOrigin === "anonymous") {\n        // CORS failed\n        window.clearTimeout( imageObj.timer );\n\n        // let\'s try with proxy instead\n        if ( options.proxy ) {\n          var src = img.src;\n          img = new Image();\n          imageObj.img = img;\n          img.src = src;\n\n          proxyGetImage( img.src, img, imageObj );\n          return;\n        }\n      }\n\n      images.numLoaded++;\n      images.numFailed++;\n      imageObj.succeeded = false;\n      img.onerror = img.onload = null;\n      start();\n    };\n  }\n\n  methods = {\n    loadImage: function( src ) {\n      var img, imageObj;\n      if ( src && images[src] === undefined ) {\n        img = new Image();\n        if ( src.match(/data:image\\/.*;base64,/i) ) {\n          img.src = src.replace(/url\\([\'"]{0,}|[\'"]{0,}\\)$/ig, \'\');\n          imageObj = images[src] = {\n            img: img\n          };\n          images.numTotal++;\n          setImageLoadHandlers(img, imageObj);\n        } else if ( isSameOrigin( src ) || options.allowTaint ===  true ) {\n          imageObj = images[src] = {\n            img: img\n          };\n          images.numTotal++;\n          setImageLoadHandlers(img, imageObj);\n          img.src = src;\n        } else if ( supportCORS && !options.allowTaint && options.useCORS ) {\n          // attempt to load with CORS\n\n          img.crossOrigin = "anonymous";\n          imageObj = images[src] = {\n            img: img\n          };\n          images.numTotal++;\n          setImageLoadHandlers(img, imageObj);\n          img.src = src;\n        } else if ( options.proxy ) {\n          imageObj = images[src] = {\n            img: img\n          };\n          images.numTotal++;\n          proxyGetImage( src, img, imageObj );\n        }\n      }\n\n    },\n    cleanupDOM: function(cause) {\n      var img, src;\n      if (!images.cleanupDone) {\n        if (cause && typeof cause === "string") {\n          Util.log("html2canvas: Cleanup because: " + cause);\n        } else {\n          Util.log("html2canvas: Cleanup after timeout: " + options.timeout + " ms.");\n        }\n\n        for (src in images) {\n          if (images.hasOwnProperty(src)) {\n            img = images[src];\n            if (typeof img === "object" && img.callbackname && img.succeeded === undefined) {\n              // cancel proxy image request\n              window[img.callbackname] = undefined; // to work with IE<9  // NOTE: that the undefined callback property-name still exists on the window object (for IE<9)\n              try {\n                delete window[img.callbackname];  // for all browser that support this\n              } catch(ex) {}\n              if (img.script && img.script.parentNode) {\n                img.script.setAttribute("src", "about:blank");  // try to cancel running request\n                img.script.parentNode.removeChild(img.script);\n              }\n              images.numLoaded++;\n              images.numFailed++;\n              Util.log("html2canvas: Cleaned up failed img: \'" + src + "\' Steps: " + images.numLoaded + " / " + images.numTotal);\n            }\n          }\n        }\n\n        // cancel any pending requests\n        if(window.stop !== undefined) {\n          window.stop();\n        } else if(document.execCommand !== undefined) {\n          document.execCommand("Stop", false);\n        }\n        if (document.close !== undefined) {\n          document.close();\n        }\n        images.cleanupDone = true;\n        if (!(cause && typeof cause === "string")) {\n          start();\n        }\n      }\n    },\n\n    renderingDone: function() {\n      if (timeoutTimer) {\n        window.clearTimeout(timeoutTimer);\n      }\n    }\n  };\n\n  if (options.timeout > 0) {\n    timeoutTimer = window.setTimeout(methods.cleanupDOM, options.timeout);\n  }\n\n  Util.log(\'html2canvas: Preload starts: finding background-images\');\n  images.firstRun = true;\n\n  getImages(element);\n\n  Util.log(\'html2canvas: Preload: Finding images\');\n  // load <img> images\n  for (i = 0; i < imgLen; i+=1){\n    methods.loadImage( domImages[i].getAttribute( "src" ) );\n  }\n\n  images.firstRun = false;\n  Util.log(\'html2canvas: Preload: Done.\');\n  if (images.numTotal === images.numLoaded) {\n    start();\n  }\n\n  return methods;\n};\n\n_html2canvas.Renderer = function(parseQueue, options){\n\n  // http://www.w3.org/TR/CSS21/zindex.html\n  function createRenderQueue(parseQueue) {\n    var queue = [],\n    rootContext;\n\n    rootContext = (function buildStackingContext(rootNode) {\n      var rootContext = {};\n      function insert(context, node, specialParent) {\n        var zi = (node.zIndex.zindex === \'auto\') ? 0 : Number(node.zIndex.zindex),\n        contextForChildren = context, // the stacking context for children\n        isPositioned = node.zIndex.isPositioned,\n        isFloated = node.zIndex.isFloated,\n        stub = {node: node},\n        childrenDest = specialParent; // where children without z-index should be pushed into\n\n        if (node.zIndex.ownStacking) {\n          // \'!\' comes before numbers in sorted array\n          contextForChildren = stub.context = { \'!\': [{node:node, children: []}]};\n          childrenDest = undefined;\n        } else if (isPositioned || isFloated) {\n          childrenDest = stub.children = [];\n        }\n\n        if (zi === 0 && specialParent) {\n          specialParent.push(stub);\n        } else {\n          if (!context[zi]) { context[zi] = []; }\n          context[zi].push(stub);\n        }\n\n        node.zIndex.children.forEach(function(childNode) {\n          insert(contextForChildren, childNode, childrenDest);\n        });\n      }\n      insert(rootContext, rootNode);\n      return rootContext;\n    })(parseQueue);\n\n    function sortZ(context) {\n      Object.keys(context).sort().forEach(function(zi) {\n        var nonPositioned = [],\n        floated = [],\n        positioned = [],\n        list = [];\n\n        // positioned after static\n        context[zi].forEach(function(v) {\n          if (v.node.zIndex.isPositioned || v.node.zIndex.opacity < 1) {\n            // http://www.w3.org/TR/css3-color/#transparency\n            // non-positioned element with opactiy < 1 should be stacked as if it were a positioned element with ‘z-index: 0’ and ‘opacity: 1’.\n            positioned.push(v);\n          } else if (v.node.zIndex.isFloated) {\n            floated.push(v);\n          } else {\n            nonPositioned.push(v);\n          }\n        });\n\n        (function walk(arr) {\n          arr.forEach(function(v) {\n            list.push(v);\n            if (v.children) { walk(v.children); }\n          });\n        })(nonPositioned.concat(floated, positioned));\n\n        list.forEach(function(v) {\n          if (v.context) {\n            sortZ(v.context);\n          } else {\n            queue.push(v.node);\n          }\n        });\n      });\n    }\n\n    sortZ(rootContext);\n\n    return queue;\n  }\n\n  function getRenderer(rendererName) {\n    var renderer;\n\n    if (typeof options.renderer === "string" && _html2canvas.Renderer[rendererName] !== undefined) {\n      renderer = _html2canvas.Renderer[rendererName](options);\n    } else if (typeof rendererName === "function") {\n      renderer = rendererName(options);\n    } else {\n      throw new Error("Unknown renderer");\n    }\n\n    if ( typeof renderer !== "function" ) {\n      throw new Error("Invalid renderer defined");\n    }\n    return renderer;\n  }\n\n  return getRenderer(options.renderer)(parseQueue, options, document, createRenderQueue(parseQueue.stack), _html2canvas);\n};\n\n_html2canvas.Util.Support = function (options, doc) {\n\n  function supportSVGRendering() {\n    var img = new Image(),\n    canvas = doc.createElement("canvas"),\n    ctx = (canvas.getContext === undefined) ? false : canvas.getContext("2d");\n    if (ctx === false) {\n      return false;\n    }\n    canvas.width = canvas.height = 10;\n    img.src = [\n    "data:image/svg+xml,",\n    "<svg xmlns=\'http://www.w3.org/2000/svg\' width=\'10\' height=\'10\'>",\n    "<foreignObject width=\'10\' height=\'10\'>",\n    "<div xmlns=\'http://www.w3.org/1999/xhtml\' style=\'width:10;height:10;\'>",\n    "sup",\n    "</div>",\n    "</foreignObject>",\n    "</svg>"\n    ].join("");\n    try {\n      ctx.drawImage(img, 0, 0);\n      canvas.toDataURL();\n    } catch(e) {\n      return false;\n    }\n    _html2canvas.Util.log(\'html2canvas: Parse: SVG powered rendering available\');\n    return true;\n  }\n\n  // Test whether we can use ranges to measure bounding boxes\n  // Opera doesn\'t provide valid bounds.height/bottom even though it supports the method.\n\n  function supportRangeBounds() {\n    var r, testElement, rangeBounds, rangeHeight, support = false;\n\n    if (doc.createRange) {\n      r = doc.createRange();\n      if (r.getBoundingClientRect) {\n        testElement = doc.createElement(\'boundtest\');\n        testElement.style.height = "123px";\n        testElement.style.display = "block";\n        doc.body.appendChild(testElement);\n\n        r.selectNode(testElement);\n        rangeBounds = r.getBoundingClientRect();\n        rangeHeight = rangeBounds.height;\n\n        if (rangeHeight === 123) {\n          support = true;\n        }\n        doc.body.removeChild(testElement);\n      }\n    }\n\n    return support;\n  }\n\n  return {\n    rangeBounds: supportRangeBounds(),\n    svgRendering: options.svgRendering && supportSVGRendering()\n  };\n};\nwindow.html2canvas = function(elements, opts) {\n  elements = (elements.length) ? elements : [elements];\n  var queue,\n  canvas,\n  options = {\n    // general\n    logging: false,\n    elements: elements,\n    background: "#fff",\n\n    // preload options\n    proxy: null,\n    timeout: 0,    // no timeout\n    useCORS: false, // try to load images as CORS (where available), before falling back to proxy\n    allowTaint: false, // whether to allow images to taint the canvas, won\'t need proxy if set to true\n\n    // parse options\n    svgRendering: false, // use svg powered rendering where available (FF11+)\n    ignoreElements: "IFRAME|OBJECT|PARAM",\n    useOverflow: true,\n    letterRendering: false,\n    chinese: false,\n\n    // render options\n\n    width: null,\n    height: null,\n    taintTest: true, // do a taint test with all images before applying to canvas\n    renderer: "Canvas"\n  };\n\n  options = _html2canvas.Util.Extend(opts, options);\n\n  _html2canvas.logging = options.logging;\n  options.complete = function( images ) {\n\n    if (typeof options.onpreloaded === "function") {\n      if ( options.onpreloaded( images ) === false ) {\n        return;\n      }\n    }\n    queue = _html2canvas.Parse( images, options );\n\n    if (typeof options.onparsed === "function") {\n      if ( options.onparsed( queue ) === false ) {\n        return;\n      }\n    }\n\n    canvas = _html2canvas.Renderer( queue, options );\n\n    if (typeof options.onrendered === "function") {\n      options.onrendered( canvas );\n    }\n\n\n  };\n\n  // for pages without images, we still want this to be async, i.e. return methods before executing\n  window.setTimeout( function(){\n    _html2canvas.Preload( options );\n  }, 0 );\n\n  return {\n    render: function( queue, opts ) {\n      return _html2canvas.Renderer( queue, _html2canvas.Util.Extend(opts, options) );\n    },\n    parse: function( images, opts ) {\n      return _html2canvas.Parse( images, _html2canvas.Util.Extend(opts, options) );\n    },\n    preload: function( opts ) {\n      return _html2canvas.Preload( _html2canvas.Util.Extend(opts, options) );\n    },\n    log: _html2canvas.Util.log\n  };\n};\n\nwindow.html2canvas.log = _html2canvas.Util.log; // for renderers\nwindow.html2canvas.Renderer = {\n  Canvas: undefined // We are assuming this will be used\n};\n_html2canvas.Renderer.Canvas = function(options) {\n  options = options || {};\n\n  var doc = document,\n  safeImages = [],\n  testCanvas = document.createElement("canvas"),\n  testctx = testCanvas.getContext("2d"),\n  Util = _html2canvas.Util,\n  canvas = options.canvas || doc.createElement(\'canvas\');\n\n  function createShape(ctx, args) {\n    ctx.beginPath();\n    args.forEach(function(arg) {\n      ctx[arg.name].apply(ctx, arg[\'arguments\']);\n    });\n    ctx.closePath();\n  }\n\n  function safeImage(item) {\n    if (safeImages.indexOf(item[\'arguments\'][0].src ) === -1) {\n      testctx.drawImage(item[\'arguments\'][0], 0, 0);\n      try {\n        testctx.getImageData(0, 0, 1, 1);\n      } catch(e) {\n        testCanvas = doc.createElement("canvas");\n        testctx = testCanvas.getContext("2d");\n        return false;\n      }\n      safeImages.push(item[\'arguments\'][0].src);\n    }\n    return true;\n  }\n\n  function renderItem(ctx, item) {\n    switch(item.type){\n      case "variable":\n        ctx[item.name] = item[\'arguments\'];\n        break;\n      case "function":\n        switch(item.name) {\n          case "createPattern":\n            if (item[\'arguments\'][0].width > 0 && item[\'arguments\'][0].height > 0) {\n              try {\n                ctx.fillStyle = ctx.createPattern(item[\'arguments\'][0], "repeat");\n              }\n              catch(e) {\n                Util.log("html2canvas: Renderer: Error creating pattern", e.message);\n              }\n            }\n            break;\n          case "drawShape":\n            createShape(ctx, item[\'arguments\']);\n            break;\n          case "drawImage":\n            if (item[\'arguments\'][8] > 0 && item[\'arguments\'][7] > 0) {\n              if (!options.taintTest || (options.taintTest && safeImage(item))) {\n                ctx.drawImage.apply( ctx, item[\'arguments\'] );\n              }\n            }\n            break;\n          default:\n            ctx[item.name].apply(ctx, item[\'arguments\']);\n        }\n        break;\n    }\n  }\n\n  return function(parsedData, options, document, queue, _html2canvas) {\n    var ctx = canvas.getContext("2d"),\n    newCanvas,\n    bounds,\n    fstyle,\n    zStack = parsedData.stack;\n\n    canvas.width = canvas.style.width =  options.width || zStack.ctx.width;\n    canvas.height = canvas.style.height = options.height || zStack.ctx.height;\n\n    fstyle = ctx.fillStyle;\n    ctx.fillStyle = (Util.isTransparent(zStack.backgroundColor) && options.background !== undefined) ? options.background : parsedData.backgroundColor;\n    ctx.fillRect(0, 0, canvas.width, canvas.height);\n    ctx.fillStyle = fstyle;\n\n    queue.forEach(function(storageContext) {\n      // set common settings for canvas\n      ctx.textBaseline = "bottom";\n      ctx.save();\n\n      if (storageContext.transform.matrix) {\n        ctx.translate(storageContext.transform.origin[0], storageContext.transform.origin[1]);\n        ctx.transform.apply(ctx, storageContext.transform.matrix);\n        ctx.translate(-storageContext.transform.origin[0], -storageContext.transform.origin[1]);\n      }\n\n      if (storageContext.clip){\n        ctx.beginPath();\n        ctx.rect(storageContext.clip.left, storageContext.clip.top, storageContext.clip.width, storageContext.clip.height);\n        ctx.clip();\n      }\n\n      if (storageContext.ctx.storage) {\n        storageContext.ctx.storage.forEach(function(item) {\n          renderItem(ctx, item);\n        });\n      }\n\n      ctx.restore();\n    });\n\n    Util.log("html2canvas: Renderer: Canvas renderer done - returning canvas obj");\n\n    if (options.elements.length === 1) {\n      if (typeof options.elements[0] === "object" && options.elements[0].nodeName !== "BODY") {\n        // crop image to the bounds of selected (single) element\n        bounds = _html2canvas.Util.Bounds(options.elements[0]);\n        newCanvas = document.createElement(\'canvas\');\n        newCanvas.width = Math.ceil(bounds.width);\n        newCanvas.height = Math.ceil(bounds.height);\n        ctx = newCanvas.getContext("2d");\n\n        ctx.drawImage(canvas, bounds.left, bounds.top, bounds.width, bounds.height, 0, 0, bounds.width, bounds.height);\n        canvas = null;\n        return newCanvas;\n      }\n    }\n\n    return canvas;\n  };\n};\n})(window,document);'},347:function(n,e){n.exports='var QRCode;!function(){function a(a){this.mode=c.MODE_8BIT_BYTE,this.data=a,this.parsedData=[];for(var b=[],d=0,e=this.data.length;e>d;d++){var f=this.data.charCodeAt(d);f>65536?(b[0]=240|(1835008&f)>>>18,b[1]=128|(258048&f)>>>12,b[2]=128|(4032&f)>>>6,b[3]=128|63&f):f>2048?(b[0]=224|(61440&f)>>>12,b[1]=128|(4032&f)>>>6,b[2]=128|63&f):f>128?(b[0]=192|(1984&f)>>>6,b[1]=128|63&f):b[0]=f,this.parsedData=this.parsedData.concat(b)}this.parsedData.length!=this.data.length&&(this.parsedData.unshift(191),this.parsedData.unshift(187),this.parsedData.unshift(239))}function b(a,b){this.typeNumber=a,this.errorCorrectLevel=b,this.modules=null,this.moduleCount=0,this.dataCache=null,this.dataList=[]}function i(a,b){if(void 0==a.length)throw new Error(a.length+"/"+b);for(var c=0;c<a.length&&0==a[c];)c++;this.num=new Array(a.length-c+b);for(var d=0;d<a.length-c;d++)this.num[d]=a[d+c]}function j(a,b){this.totalCount=a,this.dataCount=b}function k(){this.buffer=[],this.length=0}function m(){return"undefined"!=typeof CanvasRenderingContext2D}function n(){var a=!1,b=navigator.userAgent;return/android/i.test(b)&&(a=!0,aMat=b.toString().match(/android ([0-9]\\.[0-9])/i),aMat&&aMat[1]&&(a=parseFloat(aMat[1]))),a}function r(a,b){for(var c=1,e=s(a),f=0,g=l.length;g>=f;f++){var h=0;switch(b){case d.L:h=l[f][0];break;case d.M:h=l[f][1];break;case d.Q:h=l[f][2];break;case d.H:h=l[f][3]}if(h>=e)break;c++}if(c>l.length)throw new Error("Too long data");return c}function s(a){var b=encodeURI(a).toString().replace(/\\%[0-9a-fA-F]{2}/g,"a");return b.length+(b.length!=a?3:0)}a.prototype={getLength:function(){return this.parsedData.length},write:function(a){for(var b=0,c=this.parsedData.length;c>b;b++)a.put(this.parsedData[b],8)}},b.prototype={addData:function(b){var c=new a(b);this.dataList.push(c),this.dataCache=null},isDark:function(a,b){if(0>a||this.moduleCount<=a||0>b||this.moduleCount<=b)throw new Error(a+","+b);return this.modules[a][b]},getModuleCount:function(){return this.moduleCount},make:function(){this.makeImpl(!1,this.getBestMaskPattern())},makeImpl:function(a,c){this.moduleCount=4*this.typeNumber+17,this.modules=new Array(this.moduleCount);for(var d=0;d<this.moduleCount;d++){this.modules[d]=new Array(this.moduleCount);for(var e=0;e<this.moduleCount;e++)this.modules[d][e]=null}this.setupPositionProbePattern(0,0),this.setupPositionProbePattern(this.moduleCount-7,0),this.setupPositionProbePattern(0,this.moduleCount-7),this.setupPositionAdjustPattern(),this.setupTimingPattern(),this.setupTypeInfo(a,c),this.typeNumber>=7&&this.setupTypeNumber(a),null==this.dataCache&&(this.dataCache=b.createData(this.typeNumber,this.errorCorrectLevel,this.dataList)),this.mapData(this.dataCache,c)},setupPositionProbePattern:function(a,b){for(var c=-1;7>=c;c++)if(!(-1>=a+c||this.moduleCount<=a+c))for(var d=-1;7>=d;d++)-1>=b+d||this.moduleCount<=b+d||(this.modules[a+c][b+d]=c>=0&&6>=c&&(0==d||6==d)||d>=0&&6>=d&&(0==c||6==c)||c>=2&&4>=c&&d>=2&&4>=d?!0:!1)},getBestMaskPattern:function(){for(var a=0,b=0,c=0;8>c;c++){this.makeImpl(!0,c);var d=f.getLostPoint(this);(0==c||a>d)&&(a=d,b=c)}return b},createMovieClip:function(a,b,c){var d=a.createEmptyMovieClip(b,c),e=1;this.make();for(var f=0;f<this.modules.length;f++)for(var g=f*e,h=0;h<this.modules[f].length;h++){var i=h*e,j=this.modules[f][h];j&&(d.beginFill(0,100),d.moveTo(i,g),d.lineTo(i+e,g),d.lineTo(i+e,g+e),d.lineTo(i,g+e),d.endFill())}return d},setupTimingPattern:function(){for(var a=8;a<this.moduleCount-8;a++)null==this.modules[a][6]&&(this.modules[a][6]=0==a%2);for(var b=8;b<this.moduleCount-8;b++)null==this.modules[6][b]&&(this.modules[6][b]=0==b%2)},setupPositionAdjustPattern:function(){for(var a=f.getPatternPosition(this.typeNumber),b=0;b<a.length;b++)for(var c=0;c<a.length;c++){var d=a[b],e=a[c];if(null==this.modules[d][e])for(var g=-2;2>=g;g++)for(var h=-2;2>=h;h++)this.modules[d+g][e+h]=-2==g||2==g||-2==h||2==h||0==g&&0==h?!0:!1}},setupTypeNumber:function(a){for(var b=f.getBCHTypeNumber(this.typeNumber),c=0;18>c;c++){var d=!a&&1==(1&b>>c);this.modules[Math.floor(c/3)][c%3+this.moduleCount-8-3]=d}for(var c=0;18>c;c++){var d=!a&&1==(1&b>>c);this.modules[c%3+this.moduleCount-8-3][Math.floor(c/3)]=d}},setupTypeInfo:function(a,b){for(var c=this.errorCorrectLevel<<3|b,d=f.getBCHTypeInfo(c),e=0;15>e;e++){var g=!a&&1==(1&d>>e);6>e?this.modules[e][8]=g:8>e?this.modules[e+1][8]=g:this.modules[this.moduleCount-15+e][8]=g}for(var e=0;15>e;e++){var g=!a&&1==(1&d>>e);8>e?this.modules[8][this.moduleCount-e-1]=g:9>e?this.modules[8][15-e-1+1]=g:this.modules[8][15-e-1]=g}this.modules[this.moduleCount-8][8]=!a},mapData:function(a,b){for(var c=-1,d=this.moduleCount-1,e=7,g=0,h=this.moduleCount-1;h>0;h-=2)for(6==h&&h--;;){for(var i=0;2>i;i++)if(null==this.modules[d][h-i]){var j=!1;g<a.length&&(j=1==(1&a[g]>>>e));var k=f.getMask(b,d,h-i);k&&(j=!j),this.modules[d][h-i]=j,e--,-1==e&&(g++,e=7)}if(d+=c,0>d||this.moduleCount<=d){d-=c,c=-c;break}}}},b.PAD0=236,b.PAD1=17,b.createData=function(a,c,d){for(var e=j.getRSBlocks(a,c),g=new k,h=0;h<d.length;h++){var i=d[h];g.put(i.mode,4),g.put(i.getLength(),f.getLengthInBits(i.mode,a)),i.write(g)}for(var l=0,h=0;h<e.length;h++)l+=e[h].dataCount;if(g.getLengthInBits()>8*l)throw new Error("code length overflow. ("+g.getLengthInBits()+">"+8*l+")");for(g.getLengthInBits()+4<=8*l&&g.put(0,4);0!=g.getLengthInBits()%8;)g.putBit(!1);for(;;){if(g.getLengthInBits()>=8*l)break;if(g.put(b.PAD0,8),g.getLengthInBits()>=8*l)break;g.put(b.PAD1,8)}return b.createBytes(g,e)},b.createBytes=function(a,b){for(var c=0,d=0,e=0,g=new Array(b.length),h=new Array(b.length),j=0;j<b.length;j++){var k=b[j].dataCount,l=b[j].totalCount-k;d=Math.max(d,k),e=Math.max(e,l),g[j]=new Array(k);for(var m=0;m<g[j].length;m++)g[j][m]=255&a.buffer[m+c];c+=k;var n=f.getErrorCorrectPolynomial(l),o=new i(g[j],n.getLength()-1),p=o.mod(n);h[j]=new Array(n.getLength()-1);for(var m=0;m<h[j].length;m++){var q=m+p.getLength()-h[j].length;h[j][m]=q>=0?p.get(q):0}}for(var r=0,m=0;m<b.length;m++)r+=b[m].totalCount;for(var s=new Array(r),t=0,m=0;d>m;m++)for(var j=0;j<b.length;j++)m<g[j].length&&(s[t++]=g[j][m]);for(var m=0;e>m;m++)for(var j=0;j<b.length;j++)m<h[j].length&&(s[t++]=h[j][m]);return s};for(var c={MODE_NUMBER:1,MODE_ALPHA_NUM:2,MODE_8BIT_BYTE:4,MODE_KANJI:8},d={L:1,M:0,Q:3,H:2},e={PATTERN000:0,PATTERN001:1,PATTERN010:2,PATTERN011:3,PATTERN100:4,PATTERN101:5,PATTERN110:6,PATTERN111:7},f={PATTERN_POSITION_TABLE:[[],[6,18],[6,22],[6,26],[6,30],[6,34],[6,22,38],[6,24,42],[6,26,46],[6,28,50],[6,30,54],[6,32,58],[6,34,62],[6,26,46,66],[6,26,48,70],[6,26,50,74],[6,30,54,78],[6,30,56,82],[6,30,58,86],[6,34,62,90],[6,28,50,72,94],[6,26,50,74,98],[6,30,54,78,102],[6,28,54,80,106],[6,32,58,84,110],[6,30,58,86,114],[6,34,62,90,118],[6,26,50,74,98,122],[6,30,54,78,102,126],[6,26,52,78,104,130],[6,30,56,82,108,134],[6,34,60,86,112,138],[6,30,58,86,114,142],[6,34,62,90,118,146],[6,30,54,78,102,126,150],[6,24,50,76,102,128,154],[6,28,54,80,106,132,158],[6,32,58,84,110,136,162],[6,26,54,82,110,138,166],[6,30,58,86,114,142,170]],G15:1335,G18:7973,G15_MASK:21522,getBCHTypeInfo:function(a){for(var b=a<<10;f.getBCHDigit(b)-f.getBCHDigit(f.G15)>=0;)b^=f.G15<<f.getBCHDigit(b)-f.getBCHDigit(f.G15);return(a<<10|b)^f.G15_MASK},getBCHTypeNumber:function(a){for(var b=a<<12;f.getBCHDigit(b)-f.getBCHDigit(f.G18)>=0;)b^=f.G18<<f.getBCHDigit(b)-f.getBCHDigit(f.G18);return a<<12|b},getBCHDigit:function(a){for(var b=0;0!=a;)b++,a>>>=1;return b},getPatternPosition:function(a){return f.PATTERN_POSITION_TABLE[a-1]},getMask:function(a,b,c){switch(a){case e.PATTERN000:return 0==(b+c)%2;case e.PATTERN001:return 0==b%2;case e.PATTERN010:return 0==c%3;case e.PATTERN011:return 0==(b+c)%3;case e.PATTERN100:return 0==(Math.floor(b/2)+Math.floor(c/3))%2;case e.PATTERN101:return 0==b*c%2+b*c%3;case e.PATTERN110:return 0==(b*c%2+b*c%3)%2;case e.PATTERN111:return 0==(b*c%3+(b+c)%2)%2;default:throw new Error("bad maskPattern:"+a)}},getErrorCorrectPolynomial:function(a){for(var b=new i([1],0),c=0;a>c;c++)b=b.multiply(new i([1,g.gexp(c)],0));return b},getLengthInBits:function(a,b){if(b>=1&&10>b)switch(a){case c.MODE_NUMBER:return 10;case c.MODE_ALPHA_NUM:return 9;case c.MODE_8BIT_BYTE:return 8;case c.MODE_KANJI:return 8;default:throw new Error("mode:"+a)}else if(27>b)switch(a){case c.MODE_NUMBER:return 12;case c.MODE_ALPHA_NUM:return 11;case c.MODE_8BIT_BYTE:return 16;case c.MODE_KANJI:return 10;default:throw new Error("mode:"+a)}else{if(!(41>b))throw new Error("type:"+b);switch(a){case c.MODE_NUMBER:return 14;case c.MODE_ALPHA_NUM:return 13;case c.MODE_8BIT_BYTE:return 16;case c.MODE_KANJI:return 12;default:throw new Error("mode:"+a)}}},getLostPoint:function(a){for(var b=a.getModuleCount(),c=0,d=0;b>d;d++)for(var e=0;b>e;e++){for(var f=0,g=a.isDark(d,e),h=-1;1>=h;h++)if(!(0>d+h||d+h>=b))for(var i=-1;1>=i;i++)0>e+i||e+i>=b||(0!=h||0!=i)&&g==a.isDark(d+h,e+i)&&f++;f>5&&(c+=3+f-5)}for(var d=0;b-1>d;d++)for(var e=0;b-1>e;e++){var j=0;a.isDark(d,e)&&j++,a.isDark(d+1,e)&&j++,a.isDark(d,e+1)&&j++,a.isDark(d+1,e+1)&&j++,(0==j||4==j)&&(c+=3)}for(var d=0;b>d;d++)for(var e=0;b-6>e;e++)a.isDark(d,e)&&!a.isDark(d,e+1)&&a.isDark(d,e+2)&&a.isDark(d,e+3)&&a.isDark(d,e+4)&&!a.isDark(d,e+5)&&a.isDark(d,e+6)&&(c+=40);for(var e=0;b>e;e++)for(var d=0;b-6>d;d++)a.isDark(d,e)&&!a.isDark(d+1,e)&&a.isDark(d+2,e)&&a.isDark(d+3,e)&&a.isDark(d+4,e)&&!a.isDark(d+5,e)&&a.isDark(d+6,e)&&(c+=40);for(var k=0,e=0;b>e;e++)for(var d=0;b>d;d++)a.isDark(d,e)&&k++;var l=Math.abs(100*k/b/b-50)/5;return c+=10*l}},g={glog:function(a){if(1>a)throw new Error("glog("+a+")");return g.LOG_TABLE[a]},gexp:function(a){for(;0>a;)a+=255;for(;a>=256;)a-=255;return g.EXP_TABLE[a]},EXP_TABLE:new Array(256),LOG_TABLE:new Array(256)},h=0;8>h;h++)g.EXP_TABLE[h]=1<<h;for(var h=8;256>h;h++)g.EXP_TABLE[h]=g.EXP_TABLE[h-4]^g.EXP_TABLE[h-5]^g.EXP_TABLE[h-6]^g.EXP_TABLE[h-8];for(var h=0;255>h;h++)g.LOG_TABLE[g.EXP_TABLE[h]]=h;i.prototype={get:function(a){return this.num[a]},getLength:function(){return this.num.length},multiply:function(a){for(var b=new Array(this.getLength()+a.getLength()-1),c=0;c<this.getLength();c++)for(var d=0;d<a.getLength();d++)b[c+d]^=g.gexp(g.glog(this.get(c))+g.glog(a.get(d)));return new i(b,0)},mod:function(a){if(this.getLength()-a.getLength()<0)return this;for(var b=g.glog(this.get(0))-g.glog(a.get(0)),c=new Array(this.getLength()),d=0;d<this.getLength();d++)c[d]=this.get(d);for(var d=0;d<a.getLength();d++)c[d]^=g.gexp(g.glog(a.get(d))+b);return new i(c,0).mod(a)}},j.RS_BLOCK_TABLE=[[1,26,19],[1,26,16],[1,26,13],[1,26,9],[1,44,34],[1,44,28],[1,44,22],[1,44,16],[1,70,55],[1,70,44],[2,35,17],[2,35,13],[1,100,80],[2,50,32],[2,50,24],[4,25,9],[1,134,108],[2,67,43],[2,33,15,2,34,16],[2,33,11,2,34,12],[2,86,68],[4,43,27],[4,43,19],[4,43,15],[2,98,78],[4,49,31],[2,32,14,4,33,15],[4,39,13,1,40,14],[2,121,97],[2,60,38,2,61,39],[4,40,18,2,41,19],[4,40,14,2,41,15],[2,146,116],[3,58,36,2,59,37],[4,36,16,4,37,17],[4,36,12,4,37,13],[2,86,68,2,87,69],[4,69,43,1,70,44],[6,43,19,2,44,20],[6,43,15,2,44,16],[4,101,81],[1,80,50,4,81,51],[4,50,22,4,51,23],[3,36,12,8,37,13],[2,116,92,2,117,93],[6,58,36,2,59,37],[4,46,20,6,47,21],[7,42,14,4,43,15],[4,133,107],[8,59,37,1,60,38],[8,44,20,4,45,21],[12,33,11,4,34,12],[3,145,115,1,146,116],[4,64,40,5,65,41],[11,36,16,5,37,17],[11,36,12,5,37,13],[5,109,87,1,110,88],[5,65,41,5,66,42],[5,54,24,7,55,25],[11,36,12],[5,122,98,1,123,99],[7,73,45,3,74,46],[15,43,19,2,44,20],[3,45,15,13,46,16],[1,135,107,5,136,108],[10,74,46,1,75,47],[1,50,22,15,51,23],[2,42,14,17,43,15],[5,150,120,1,151,121],[9,69,43,4,70,44],[17,50,22,1,51,23],[2,42,14,19,43,15],[3,141,113,4,142,114],[3,70,44,11,71,45],[17,47,21,4,48,22],[9,39,13,16,40,14],[3,135,107,5,136,108],[3,67,41,13,68,42],[15,54,24,5,55,25],[15,43,15,10,44,16],[4,144,116,4,145,117],[17,68,42],[17,50,22,6,51,23],[19,46,16,6,47,17],[2,139,111,7,140,112],[17,74,46],[7,54,24,16,55,25],[34,37,13],[4,151,121,5,152,122],[4,75,47,14,76,48],[11,54,24,14,55,25],[16,45,15,14,46,16],[6,147,117,4,148,118],[6,73,45,14,74,46],[11,54,24,16,55,25],[30,46,16,2,47,17],[8,132,106,4,133,107],[8,75,47,13,76,48],[7,54,24,22,55,25],[22,45,15,13,46,16],[10,142,114,2,143,115],[19,74,46,4,75,47],[28,50,22,6,51,23],[33,46,16,4,47,17],[8,152,122,4,153,123],[22,73,45,3,74,46],[8,53,23,26,54,24],[12,45,15,28,46,16],[3,147,117,10,148,118],[3,73,45,23,74,46],[4,54,24,31,55,25],[11,45,15,31,46,16],[7,146,116,7,147,117],[21,73,45,7,74,46],[1,53,23,37,54,24],[19,45,15,26,46,16],[5,145,115,10,146,116],[19,75,47,10,76,48],[15,54,24,25,55,25],[23,45,15,25,46,16],[13,145,115,3,146,116],[2,74,46,29,75,47],[42,54,24,1,55,25],[23,45,15,28,46,16],[17,145,115],[10,74,46,23,75,47],[10,54,24,35,55,25],[19,45,15,35,46,16],[17,145,115,1,146,116],[14,74,46,21,75,47],[29,54,24,19,55,25],[11,45,15,46,46,16],[13,145,115,6,146,116],[14,74,46,23,75,47],[44,54,24,7,55,25],[59,46,16,1,47,17],[12,151,121,7,152,122],[12,75,47,26,76,48],[39,54,24,14,55,25],[22,45,15,41,46,16],[6,151,121,14,152,122],[6,75,47,34,76,48],[46,54,24,10,55,25],[2,45,15,64,46,16],[17,152,122,4,153,123],[29,74,46,14,75,47],[49,54,24,10,55,25],[24,45,15,46,46,16],[4,152,122,18,153,123],[13,74,46,32,75,47],[48,54,24,14,55,25],[42,45,15,32,46,16],[20,147,117,4,148,118],[40,75,47,7,76,48],[43,54,24,22,55,25],[10,45,15,67,46,16],[19,148,118,6,149,119],[18,75,47,31,76,48],[34,54,24,34,55,25],[20,45,15,61,46,16]],j.getRSBlocks=function(a,b){var c=j.getRsBlockTable(a,b);if(void 0==c)throw new Error("bad rs block @ typeNumber:"+a+"/errorCorrectLevel:"+b);for(var d=c.length/3,e=[],f=0;d>f;f++)for(var g=c[3*f+0],h=c[3*f+1],i=c[3*f+2],k=0;g>k;k++)e.push(new j(h,i));return e},j.getRsBlockTable=function(a,b){switch(b){case d.L:return j.RS_BLOCK_TABLE[4*(a-1)+0];case d.M:return j.RS_BLOCK_TABLE[4*(a-1)+1];case d.Q:return j.RS_BLOCK_TABLE[4*(a-1)+2];case d.H:return j.RS_BLOCK_TABLE[4*(a-1)+3];default:return void 0}},k.prototype={get:function(a){var b=Math.floor(a/8);return 1==(1&this.buffer[b]>>>7-a%8)},put:function(a,b){for(var c=0;b>c;c++)this.putBit(1==(1&a>>>b-c-1))},getLengthInBits:function(){return this.length},putBit:function(a){var b=Math.floor(this.length/8);this.buffer.length<=b&&this.buffer.push(0),a&&(this.buffer[b]|=128>>>this.length%8),this.length++}};var l=[[17,14,11,7],[32,26,20,14],[53,42,32,24],[78,62,46,34],[106,84,60,44],[134,106,74,58],[154,122,86,64],[192,152,108,84],[230,180,130,98],[271,213,151,119],[321,251,177,137],[367,287,203,155],[425,331,241,177],[458,362,258,194],[520,412,292,220],[586,450,322,250],[644,504,364,280],[718,560,394,310],[792,624,442,338],[858,666,482,382],[929,711,509,403],[1003,779,565,439],[1091,857,611,461],[1171,911,661,511],[1273,997,715,535],[1367,1059,751,593],[1465,1125,805,625],[1528,1190,868,658],[1628,1264,908,698],[1732,1370,982,742],[1840,1452,1030,790],[1952,1538,1112,842],[2068,1628,1168,898],[2188,1722,1228,958],[2303,1809,1283,983],[2431,1911,1351,1051],[2563,1989,1423,1093],[2699,2099,1499,1139],[2809,2213,1579,1219],[2953,2331,1663,1273]],o=function(){var a=function(a,b){this._el=a,this._htOption=b};return a.prototype.draw=function(a){function g(a,b){var c=document.createElementNS("http://www.w3.org/2000/svg",a);for(var d in b)b.hasOwnProperty(d)&&c.setAttribute(d,b[d]);return c}var b=this._htOption,c=this._el,d=a.getModuleCount();Math.floor(b.width/d),Math.floor(b.height/d),this.clear();var h=g("svg",{viewBox:"0 0 "+String(d)+" "+String(d),width:"100%",height:"100%",fill:b.colorLight});h.setAttributeNS("http://www.w3.org/2000/xmlns/","xmlns:xlink","http://www.w3.org/1999/xlink"),c.appendChild(h),h.appendChild(g("rect",{fill:b.colorDark,width:"1",height:"1",id:"template"}));for(var i=0;d>i;i++)for(var j=0;d>j;j++)if(a.isDark(i,j)){var k=g("use",{x:String(i),y:String(j)});k.setAttributeNS("http://www.w3.org/1999/xlink","href","#template"),h.appendChild(k)}},a.prototype.clear=function(){for(;this._el.hasChildNodes();)this._el.removeChild(this._el.lastChild)},a}(),p="svg"===document.documentElement.tagName.toLowerCase(),q=p?o:m()?function(){function a(){this._elImage.src=this._elCanvas.toDataURL("image/png"),this._elImage.style.display="block",this._elCanvas.style.display="none"}function d(a,b){var c=this;if(c._fFail=b,c._fSuccess=a,null===c._bSupportDataURI){var d=document.createElement("img"),e=function(){c._bSupportDataURI=!1,c._fFail&&_fFail.call(c)},f=function(){c._bSupportDataURI=!0,c._fSuccess&&c._fSuccess.call(c)};return d.onabort=e,d.onerror=e,d.onload=f,d.src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAUAAAAFCAYAAACNbyblAAAAHElEQVQI12P4//8/w38GIAXDIBKE0DHxgljNBAAO9TXL0Y4OHwAAAABJRU5ErkJggg==",void 0}c._bSupportDataURI===!0&&c._fSuccess?c._fSuccess.call(c):c._bSupportDataURI===!1&&c._fFail&&c._fFail.call(c)}if(this._android&&this._android<=2.1){var b=1/window.devicePixelRatio,c=CanvasRenderingContext2D.prototype.drawImage;CanvasRenderingContext2D.prototype.drawImage=function(a,d,e,f,g,h,i,j){if("nodeName"in a&&/img/i.test(a.nodeName))for(var l=arguments.length-1;l>=1;l--)arguments[l]=arguments[l]*b;else"undefined"==typeof j&&(arguments[1]*=b,arguments[2]*=b,arguments[3]*=b,arguments[4]*=b);c.apply(this,arguments)}}var e=function(a,b){this._bIsPainted=!1,this._android=n(),this._htOption=b,this._elCanvas=document.createElement("canvas"),this._elCanvas.width=b.width,this._elCanvas.height=b.height,a.appendChild(this._elCanvas),this._el=a,this._oContext=this._elCanvas.getContext("2d"),this._bIsPainted=!1,this._elImage=document.createElement("img"),this._elImage.style.display="none",this._el.appendChild(this._elImage),this._bSupportDataURI=null};return e.prototype.draw=function(a){var b=this._elImage,c=this._oContext,d=this._htOption,e=a.getModuleCount(),f=d.width/e,g=d.height/e,h=Math.round(f),i=Math.round(g);b.style.display="none",this.clear();for(var j=0;e>j;j++)for(var k=0;e>k;k++){var l=a.isDark(j,k),m=k*f,n=j*g;c.strokeStyle=l?d.colorDark:d.colorLight,c.lineWidth=1,c.fillStyle=l?d.colorDark:d.colorLight,c.fillRect(m,n,f,g),c.strokeRect(Math.floor(m)+.5,Math.floor(n)+.5,h,i),c.strokeRect(Math.ceil(m)-.5,Math.ceil(n)-.5,h,i)}this._bIsPainted=!0},e.prototype.makeImage=function(){this._bIsPainted&&d.call(this,a)},e.prototype.isPainted=function(){return this._bIsPainted},e.prototype.clear=function(){this._oContext.clearRect(0,0,this._elCanvas.width,this._elCanvas.height),this._bIsPainted=!1},e.prototype.round=function(a){return a?Math.floor(1e3*a)/1e3:a},e}():function(){var a=function(a,b){this._el=a,this._htOption=b};return a.prototype.draw=function(a){for(var b=this._htOption,c=this._el,d=a.getModuleCount(),e=Math.floor(b.width/d),f=Math.floor(b.height/d),g=[\'<table style="border:0;border-collapse:collapse;">\'],h=0;d>h;h++){g.push("<tr>");for(var i=0;d>i;i++)g.push(\'<td style="border:0;border-collapse:collapse;padding:0;margin:0;width:\'+e+"px;height:"+f+"px;background-color:"+(a.isDark(h,i)?b.colorDark:b.colorLight)+\';"></td>\');g.push("</tr>")}g.push("</table>"),c.innerHTML=g.join("");var j=c.childNodes[0],k=(b.width-j.offsetWidth)/2,l=(b.height-j.offsetHeight)/2;k>0&&l>0&&(j.style.margin=l+"px "+k+"px")},a.prototype.clear=function(){this._el.innerHTML=""},a}();QRCode=function(a,b){if(this._htOption={width:256,height:256,typeNumber:4,colorDark:"#000000",colorLight:"#ffffff",correctLevel:d.H},"string"==typeof b&&(b={text:b}),b)for(var c in b)this._htOption[c]=b[c];"string"==typeof a&&(a=document.getElementById(a)),this._android=n(),this._el=a,this._oQRCode=null,this._oDrawing=new q(this._el,this._htOption),this._htOption.text&&this.makeCode(this._htOption.text)},QRCode.prototype.makeCode=function(a){this._oQRCode=new b(r(a,this._htOption.correctLevel),this._htOption.correctLevel),this._oQRCode.addData(a),this._oQRCode.make(),this._el.title=a,this._oDrawing.draw(this._oQRCode),this.makeImage()},QRCode.prototype.makeImage=function(){"function"==typeof this._oDrawing.makeImage&&(!this._android||this._android>=3)&&this._oDrawing.makeImage()},QRCode.prototype.clear=function(){this._oDrawing.clear()},QRCode.CorrectLevel=d}();\n'},351:function(n,e,t){t(66)(t(346))},352:function(n,e,t){t(66)(t(347))},353:function(n,e){n.exports="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMgAAADICAYAAACtWK6eAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyNpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMDE0IDc5LjE1Njc5NywgMjAxNC8wOC8yMC0wOTo1MzowMiAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6OTk2QkI4RkE3NjE2MTFFNUE4NEU4RkIxNjQ5MTYyRDgiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6OTk2QkI4Rjk3NjE2MTFFNUE4NEU4RkIxNjQ5MTYyRDgiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIChNYWNpbnRvc2gpIj4gPHhtcE1NOkRlcml2ZWRGcm9tIHN0UmVmOmluc3RhbmNlSUQ9InhtcC5paWQ6NjU2QTEyNzk3NjkyMTFFMzkxODk4RDkwQkY4Q0U0NzYiIHN0UmVmOmRvY3VtZW50SUQ9InhtcC5kaWQ6NjU2QTEyN0E3NjkyMTFFMzkxODk4RDkwQkY4Q0U0NzYiLz4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz5WHowqAAAXNElEQVR42uxda4xd1XVe53XvvD2eGQ/lXQcKuDwc2eFlCAGnUn7kT6T86J/+aNTgsWPchJJYciEOCQ8hF+G0hFCIHRSEqAuJBCqRaUEIEbmBppAIBGnESwZje8COZ+y587j3PLq+ffadGJix53HvPevcuz60xPjec89ZZ+39nf04+9vLSZKEFArFzHA1BAqFEkShUIIoFEoQhUIJolAoQRQKJYhCoQRRKJQgCoUSRKFQKEEUCiWIQrFo+Gv/8/YH+f/nsMWSHHMChyhxqPTTdyncWyJ3ScD/ztipiB3wXSqu6P17avN+TyFC5ggv4tRnmoxWTP1+5F+Mz17GPvPl49EKBWd3UsfXllPiso8VcYtmPba3fNuKrBVXrGFCbrdPwXndFL49ltI367roOpSUI4pGypv9s7q+ltj6JxqOQ07Bo/DgxGb2/a8cX0CnAWXJ5etz2TqdHiXHKlKj9w6i9XX8Ic41DmI8FVHhmmXk85MmRhCzJoiTWnig9LfJRHihgydxzAxJhBr7Bh/hK3yu+p9568FliTJF2aKMZfVd/kQOcKP6OBmS9+Rjm4zJ6faoeN0gOUn61MncLX4CJ+MRhe+P/dRxhfew2Df4CF/hs4jWg8vQYUKYMuWyRRkLjeHQ8YP0Z9mekVjA8Qj3VVcuoeDiXu63lkUE0ym6FA5PXBaNVr7qtPumGyPR4Bt8hK/wWUR5chn6XJYoU5StUHL8l+XEx2axhkS6yk+chJuP4rXLyOkIKJkS0B67adcqfL/0Y4pixxSysK6V8Yl9Mz7i3272NRFlhzJsu24Z5l9E9Ahmwfrpoj7uw3fZtktsRZKjIXnndlLxin7+W8ZTBwPf6I+Tg9HwxK2Ob8citbCoBoaxBxMCvsFH+CqjHCtUvLzflKWUcpwB91gupG5f9/Rtx39ZZBtmWyJtphKzHTQW0diP36b4aJmcLj/zGaSkHJPb4SWFi/tOJd8bTqd9s48VBRh4RKeUX/vjgXg8cpyCmz05xkJylxSoa8M5RF0eJaVIIkGOsg2yTc3UgpD94psiWxEOqDNYoOIXuHnGwE5AXUTFi46FTnRw4l/dwEm7/pSxcYnCF/gE3zInh52RRJkVP7/MlKFQcgCbjifHTAQBfsb2qsgBO3e1Cpf3UXBej3nRJKKrxU/rcH/pKzz4vNIQuRJTEmZklbg6EL4SPsE3GQPzinmfhbJDGQolB+r8w58abs5y8DqRt4ABeptLRR7koY9NleybEYw/MPisvF/ayT1/SvDewcnIcG32wfiCAbEvoCZyGaGsitdyz6XdTctQJq6fcT5mloNfYvu5yFZkpEz+RT0UrFoqpxVBV+vQxIrkaPnrbqdvXs6hcjbU+Jq4Nvvwd/BFRNeq2npwWfkX95iyE9p6PM72P/MhCPANTBSKu5WITHcC074Y9CUTkYglKBgcV/aVtlM5Kpp/RHFjDdfka7MP/2wG6m72661QNigjlBXKTGBtsjWKNs5atCf44Uds3xc5YD8Wknd2BxWuGjCzIxLWQzlFj+IjU108OL7bafM5sm5DDdfka/8T+9AJXyTMpqFsUEYoK5SZ0NbjVlvX500Q4Ha2A+JuCcEvhVS8qp/8MzspHhMSfO7mVPaP35BMRp9JsCQldbX+hmvxNfnamzJfqVvtWnGZoGxQRigroYs6UbfvOGHn4ORVkTaIbEWwtqg3MNO+Zql0JGCdVuCayhDuG9uJB7vp+oR17FbZc+NauCauLWLmKkqXr6NsUEYoK6GtxwY6CXXnEs0n2faIHLCPhhR8bikFKwRN+xZddHWu5a7Ol9yCZ2ZwHKdOxufGNeKRqS/hmnLWW1VMmQSrl5oyEkqOPbZu02IJAsic9sU7B+5uF9cOmqUfeLOdOaAZYb/CA+M/Ic9NxUoYMNfD/PT84f7xB807EAnrrbgMUBZt1w1SEpCIqfjF1Om5EuQNth0iu1r8tPLP76LCpX2yWpHDk2dGH018p6brtD5hOHf04cR3okOTZ0lqPVAW3gVdlMhdrfsTW6drRhDgRrYJcbeKZQxTkenvegNt6YBQwrQvOxG+P3ZHEia9TuClS9Br1XKge8XnxLlxjelzZ/2w4tijDMxyoHIsVQg1zvYPcy7KeZx4jG2zyFakFJF7Whu1XT2QvhfJeryeVNdplYPo4Pi9hKd7VVxVC8O5cH4+N65hXgoKuGfEHmWAskjGxI49Ntu6XHOCAD9ie1PcLSepjDNY00fB8m6KpSyJx/jgg9LfJEfLK40818w+LXY5e5zKaMfKl+DcIlSCZp0cd3U59igDI4+WOa2LunvfvDoD9RrcNLqAjDy3yzfrtKqbAkggSDIZmSlYxzz9a8BaJ101zF2rh3BuSTJaCKGMDEGujHbedXch0X2ebbdEkkDC6a9cQoWVguS53P0JP5xcHY1W/tppD9KxgrdAw5QxnwPn4nOukrPeqkzBJb0m9oJltLtt3a07QYD1IkMAeS7/hw0BXMhzJwXJc/eV7kuiyIN8OOGuUhLP06JUeoxz4FxiZLRouTsDM9WO2OdBRtsIgrzHtk3kgH00JO+cTipc2S9jqyCaluf2xwcnfuB6LndHuEsSzdP4N/gtzoFzSZHRIsaQQiPmidyXgttsnW0YQYDvsh2ROGBPxkMqXjNA/qlCFsnZ8UdlX+kfk0pymlnMWH2JOBfz0sWI+C3OMS1dzPphhPVWHOPC5wdMzIUOzFFHb1lwB2ARF+ZOPt0gshWBPLe/wCRZlu6CIkSei/cE0fD4g2ZbVWceyxH5WPwGvzXrrSTJaDnG7oBoGS3qaCULggCPsv1W5IAd8tzLllJwvpx1WthMIfyg9OVotHy1WVQ4V37wsfgNfkuSZLQcW8Q4lruU/RVbRykrggDXiwwN3uQWnXTa1xMkz2W/on2lndNajpNtAGePw2/MOicBMlqs+8K7GBNbjrFgGe2iX0nUgiAvs+0S2YpgndaFPVRc3SdmVanZlfGjifOiw5PrT/oGvPpG/vDkEH4jZ70Vt86rl5rYimmdP41/s3Uzc4Isup9XNxwvz+0tyNAlONPrtO6hctR+QnluKqNt52O3pxvtClhvxTH0egtmEwbBMlrUxU21OFGtCHKYbavIATv3j90z26kIea4QZRtahfhIuT0anrjH7O3rpjNVHzPIaLG3Lh8Tj5TbRQihjlNyehxTwTLarbZOiiEIcBfbPnGhMtroChXW9JN/VqeYdyPEY4nwwPj6ZCL8C1T+T61JhDqRv8MxZgwlJG2BxzEsrBmgeEzseqt9ti6SNIIA8t6wm901eFDZ66d7M4UkQ56LVgTTvvtKaRqFqoTWymjxGb6LpUzrImYcuzaOIWKJmAptPWpaB2sd+V+yvSB1wB6s7qXgwiUyBpbJdBqFq6MjU18mKCKhRsTyEbx558/wnRmYJzLiV+DYBat6JQ/MX7B1UCxBAKHy3IQrH6W7MhY9MWkUMNAN948/8Mm35/jMDIKlpC3gmBWQtsAjifkE61b36kGQP7DdL7KrVZXnXiYpjYKZxj09Gh7f4kB4yIa/8ZmU1brIIYiYIXaJ3Nbjflv3xBME+DZbSVwIzfIIK89dJkSea18Ihu+XflD9yPztCJnW5Ri5VRntpNh8giVb5ygvBIHu9yaRrchYRO6fFU0CSTPQlDLte6zshx9O3g3D3yJajySd4EDaAsQMsRPaetxk61zty+YTCXRqjf9jO19cOLnyYV+p8QffpcreMXJ7BeRgh77Ds6SIYhGbMBgB2tld1DW0nGL4VxbZfKBbdUHdhol1dl7mOi0MOjttGgWT11lAwU9r1mMSsX0oxwSxgYyWOvKXtiAvBPkV239I7GqZdVqX9FDw2V5+UoYipn2nt/WRMK3LMQlW9poYCZ7WfcrWsdwSBNggMrRYdcLdhjas0+q28lzJOc8bOU7jWLh2AwzEyLxclYm6Z2ZuBEE+YLtTZEVA9tzPdBh5biJ3q5rGD8yRjXbNAPkcm0RuyjTUqf3NQBDge2yHJFaGeDyi4tUD5J3WIXmzs8Y9NDgG3un80OCYIDZCHxqHbJ2iZiEIGmnB8twgzYIkd7vMxiBON59GLJyBQLKMdiM1qOPXyMn2f2f7X5EDdshzkUbhAtED0oZMXCAGiIXgtAW/YXusURdr9NsoufLcgmP20zKy2ErrNSNGRuunMUAshL7zABq61q/RBPkd2yNSn57+X3ZTQZA8t7H3H5p7RwwEt6KP2DrUtAQBIIUsiwt99Kf+tydFntuocVhVRltNWyBTRlumGslopRNkhO1mkRVlLCT3jHYzqyU48WSN+1ZWRou0BZDRyp3Ju9nWnaYnCHA3216JlQWy0gKy557dJSaNQn0nKNL1VrhnwTLavbbOUKsQBBApzzVpFHqsPFdIGoW6AfeG7cMwrcv3TC0io80LQZ5me07kU3WkYqSlhYvkpFGoz8C8bO7RyGjlpi14ztaVliMIIFOeizQKbpI+WdsDGfLcWvcmsaK53b4gdUW3lENZXjxrgrzNdq/IAftohbzzOql4eV/zjUUcu96K7w33KFhGi7rxVisTBEBSxWPiiqYqz71mGfmDQuS5tSIHstHyPZnd7+XKaI+RgKSxEggySWmKaXkVaSwi5xSbRmGiSdZpxVZGy/eEexMso73R1o2WJwiwk+11kQNZrNO6oo+Cc7vz39Wy07q4l+CKfnNvQu/ndVsnSAkifcCOAXq7R8W1y9JdRvI87QvfnTRtgdPeujLavBLkv9meEPnUHS2Tf1EPFT67lOKRnE77munrsrkH/+IeydPXqAO/VoLMDMhz5T2irTzXpFHoKeRPnluV0XYX0mlduTLamIRJtKUR5CDbbSIrGPfX/eUdVFyTQ3luku6OaNIW/HmH5LQFt9k6oAQ5Ab7PNiyxkmGndUhRvTNyJM9F1wrZaM9IZbQmG63MocewxIejRIKg+DaKbEXGI3KWBtT2hUFKyonUZeEfB3xkX4vsM3wXvIx/IwmMqCu0WH/B9qLIpzG6Wp/rpWBFj/x1WnaCAb4G7LPgad0XbZmTEmTukDnti0yzgZvKcwNPtDzXyGjZR5ONFincVEbbVAR5je0hkU/lkTL5F3TZzQ2EvjysJr1hH/0LuiVPTz9ky1oJsgB8iwQsN5hplISns5Hn9hXl9eurMlr2zUzrVsQuk5m0ZUxKkIXhKNsWkQN2yHNPhzx3WbqQMRZGYCOjXWZ8FDzjtsWWsRJkEfgh2zvyOvhWnovsucu75GTPtdlo4RN8i+W+s3nHli0pQRaPIXEeVeW53V46YJciz2Uf4IvxiX0juW/9h/JQ8fJCkGfZnpE5YK9QsHIJBZcIkOdW141d3Gt8EiyjfcaWqRKk6Z84kOc6duODjmzluUZGyz4g6Q18UhltaxHkXbbtIgfsRyvknQt5bobZc6dltP3Gl0SudmW7LUslSJ1mPUbFeWVUepDnDpB3SgazRtW0BXxt+ABfhE7rypyVbCKCTLF9U2QrgjQKg3b7zskGv3eI0+XsuDZ8EJy2YJMtQyVIHfEztldFDtghz728j4LzGphGoZq2gK9ZMDuwiH3ngTJ7OG+VLY8EAeTKc9ts9lwk42zEOi2st+JrYZIA1xYso12Xx4qWV4K8xPZzka3ISCrPDVY1YJ1WtfVYZWW0ctdbPW7LTAnSQHyDJCoykEYhTNdpuUsK6YDZqQ85cG5cw6y3CsWmLYBXG/NayfJMkI8oVR/KG7AfC8k7u4MKVw2kM1r1eB2RpDNXuAauJVhGe6stKyVIBrid7YA4r6o5N5BG4cxOI3mtaeWtymj53LiG4FwmKJs78lzB8k4QVIsN4ryqynN7AzP1ShXIc2tYg3GuSpJO6/aKltHK3KWmhQgCPMm2R+SAfTSkANlzV9Rw2rc6MDcyWtHZaPfYsiElSPaQOYVYiSnxiIprB8kpeGn+v8U2mZD8FjxzTpybKjqtqwQ5Od5g2yGyq4Xsued3UeHSvsW3IlUZLZ8L5xSctmCHLRMliCBgN/AJcV7F6SpbjBe8gUWkUaimLeBzmOUsU2JltOMkcbd+JQiNkYB8ErNVbPe0Nmq72i4kXMiwNUnfe+AcOJfgfCWbbVkoQQTiR2xvivPKynODNX0ULF9AGoVq2gL+Lc4hWEaL2N/XTBWq2Qgic3BYled2+ekeVfOV51az0WKNF59DsIx2XbNVpmYkyPNsuyWSBBJYf+USKsxHnlvNRsu/8WXLaHfb2CtBcoD1Ir2CPJf/wxSt2xmkupGT9c6QtoCPNdO66FfJldGub8aK1KwEeY9tm8gB+2hI3jmdVLii/+RbBdktfHAsfpPIfSm4zcZcCZIjfJftiMQBO1IQQBrrn3qCRYZ20SOOMTLacbHrrRDjW5q1EjUzQbiTTzeIbEUgz+232XNne59RfX+CbLT9omW0iHFFCZJPPMr2W5EDdshzL1tKwfkzrNOqrrfi73CMYBntKzbGpATJL64X6RXWZRVtxlnP+VgaBZO2wEu/wzGatkAJUk+8zLZLZCuCdVoXciux+rhVuXYVMD7Dd7Hc9Va7bGyVIE0Amf3kaXnuIHm9qTwXhr/xmWAZbUXk+E4JsmAcZtsqcsAOee6Z7VS08lwY/sZngmW0W21MlSBNhLvY9onzCqtIxipUuKqf3L6iMfyNz4RO6+6zsWwJ+NRawNvep8S1IhMxucie+8VT0o+6PIqPiB17rG+lCtNqBPkl2wts14gbsCONwqVLzT8Fr7d6wcawZeBS60Hm1GSSTu+a6d5EY6cEyQ5/YLtf4oCd4iQ1ma3H/TZ2SpAWwLfZSqSYK0o2ZqQEaQ1AN32T1vs54yYbMyVIC+GBVuwyLLBL+kCr3rzb4oV/vdZ/jZESZHb8iqS9F5GFp2yMlCAtjCENgcZGCTI79rPdqWH4FO60sVGCKOh7bIc0DNM4ZGNCShAFEFKOsyDVARttTJQgGoJpPMb2Gw2DicFjGgYlyExYpyHQGChBZsfv2B5p4ft/xMZAoQSZFZso3TKo1VC2965QgpwQI2w3t+B932zvXaEEOSnuZtvbQve7196zQgkyZ6zXe1UoQWbH02zPtcB9PmfvVaEEmTeG9B6VIIrZ8RbbvU18f/fae1QoQRYMJKU81oT3dYwkJj1VguQOk9REaY2Pw4323hRKkEVjJ9vrTXQ/r9t7UihBaobr9V6UIIrZ8Wu2J5rgPp6w96JQgtQcG2jmhGl5QWzvQaEEqQsOst2WY/9vs/egUILUtZIN59Dv4ZyTWwmSEyDnUx7luRtJar4qJUjT4RdsL+bI3xetzwolSMOwTn1Vgihmx2tsD+XAz4esrwolSMPxLZK9XGPS+qhQgmSCo2xbBPu3xfqoUIJkhh+yvSPQr3esbwolSOYYUp+UIIrZ8SzbM4L8ecb6pFCC6BNbWw8lSB7wLtt2AX5st74olCDikPWskfRZNSVIi2OKst2+c5P1QaEEEYuH2V7N4Lqv2msrlCDisa5FrqkEUSwIL7E93sDrPW6vqVCC5AaN0l/kVZ+iBGlxfMR2awOuc6u9lkIJkjvcwXagjuc/YK+hUILkEgnVdxeRDfYaCiVIbvEk2546nHePPbdCCZJ7rMvJORVKkEzwBtuOGp5vhz2nQgnSNMBu6uM1OM84Nedu80qQFscY1SYfx2Z7LoUSpOlwH9ubi/j9m/YcCiWIDth1YK4EaUU8z7Z7Ab/bbX+rUII0PdY36DcKJUgu8R7btnkcv83+RqEEaRncwnZkDscdsccqlCAthQrbDXM47gZ7rEIJ0nJ4lO2VE3z/ij1GoQRpWaxb4HcKJUhL4GW2XTN8vst+p1CCtDw+Oc6Y6/hEoQRpCRxm23rcv7fazxRKEIXFXZRuwBDZvxUC4GsIREHflguDkyQqaVYotIulUChBFAoliEKhBFEolCAKhRJEoVCCKBRKEIVCCaJQKJQgCoUSRKFQgigUShCFIhP8vwADACog5YM65zugAAAAAElFTkSuQmCC"},392:function(n,e,t){n.exports={render:function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",{staticClass:"mian"},[t("div",{staticClass:"con-answer",attrs:{id:"shareContent"}},[t("div",{staticClass:"main-wrap content-wrap"},[n._m(0),n._v(" "),t("div",{staticClass:"content-inner"},[n._m(1),n._v(" "),t("img",{attrs:{src:n.imgUrl}}),n._v(" "),n._m(2),n._v(" "),n._m(3)])]),n._v(" "),t("div",{attrs:{id:"qrcode"}})]),n._v(" "),t("footer",{staticClass:"footer-center",on:{click:n.showBase}},[t("button",{staticClass:"btn-share",attrs:{id:"btnShare"}},[n._v("截 图")])]),n._v(" "),t("img",{attrs:{src:n.Img}})])},staticRenderFns:[function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",{staticClass:"headline"},[t("div",{staticClass:"img-place-holder"})])},function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",{staticClass:"question"},[t("div",{staticClass:"answer"},[t("div",{staticClass:"meta"},[t("span",{staticClass:"author"},[n._v("Tristan，")]),t("span",{staticClass:"bio"},[n._v("Anchor Man@虎扑拓海")])]),n._v(" "),t("div",{staticClass:"content"},[t("p",[n._v("面对训练有素的兰尼斯特军队，龙的战斗方式概括起来：")]),n._v(" "),t("p",[n._v("1 删除整行，")]),n._v(" "),t("p",[n._v("2 删除整列，")]),n._v(" "),t("p",[n._v("3 清空表格内容。")])])]),n._v(" "),t("div",{staticClass:"view-more"},[t("a",{attrs:{href:"http:\n      <!-- <!-- //www.zhihu.com/question/63432129"}},[n._v("查看知乎讨论"),t("span",{staticClass:"js-question-holder"})])]),n._v(" --> -->\n\n      ")])},function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",{staticClass:"question"},[t("h2",{staticClass:"question-title"},[n._v("有哪些我们以为是中国特色的东西，其实全世界都一样？")]),n._v(" "),t("div",{staticClass:"answer"},[t("div",{staticClass:"meta"},[t("span",{staticClass:"author"},[n._v("范梵，")]),t("span",{staticClass:"bio"},[n._v("晴耕雨读")])]),n._v(" "),t("div",{staticClass:"content"},[t("p",[n._v("在美国念书的时候，有一次坐老美的车，闲来无事就跟他扯了扯国内是怎样追女生的，说得起劲我就给他说，在中国如果你对一个妹子很好，但是她不喜欢你那她就会给你发「好人卡」（nice person card，我一激动瞎编的……）。")]),n._v(" "),t("p",[n._v("我想了想他大概不知道好人卡是什么，正想跟他解释，他突然恍然大悟般地地拍着方向盘跟我说：「对对对，我曾经追过一个女生好久，后来她也跟我说：你是个很好的人，但是我们不适合。」")]),n._v(" "),t("p",[n._v("虽然隔着太平洋那么宽的文化鸿沟，我们的心里却流下了相同的泪水 T-T。")])])]),n._v(" "),t("div",{staticClass:"answer"},[t("div",{staticClass:"meta"},[t("span",{staticClass:"author"},[n._v("Moritz，")]),t("span",{staticClass:"bio"},[n._v("Assistenzarzt Chirurgie")])]),n._v(" "),t("div",{staticClass:"content"},[t("p",[n._v("什么自然疗法，排除身体负能量疗法，水晶疗法，Fengshui……在欧洲拥趸甚众。")]),n._v(" "),t("p",[n._v("在德国不要太受欢迎的针灸就不说了，毕竟是被验证有效果的。但的确太火了，比国内火多了——处处可见打着针灸旗号的疗养院，甚至医师协会都向执业医生提供针灸课程。")]),n._v(" "),t("p",[n._v("然后那天在医院食堂吃午饭，旁边一排妇产科的医生护士，其中有几个应该还是 Oberärztin（高级医生，相当于国内副高以上级别吧），听到她们的对话：")]),n._v(" "),t("p",[n._v("「据说茶叶是碱性食品，对身体好……」")]),n._v(" "),t("p",[n._v("当时就眼前一黑，对这个世界绝望了。")])])]),n._v(" "),t("div",{staticClass:"view-more"},[t("a",{attrs:{href:"http:\n      <!-- <!-- //www.zhihu.com/question/26097247"}},[n._v("查看知乎讨论"),t("span",{staticClass:"js-question-holder"})])]),n._v(" --> -->\n\n      "),t("h2",{staticClass:"question-title"},[n._v("dfjdsjfaldsjfl jdsdfjdsjfalds jfljdsdfjdsjfaldsj ljdsdfjdsjfaldsjfljdsdfjdsj faldsjfljdsdfjds dsjfljdsdfjdsjfaldsjfljdsdfjdsjfaldsjfl jdsdfjdsjfaldsjfljds")])])},function(){var n=this,e=n.$createElement,r=n._self._c||e;return r("div",{staticClass:"question"},[r("h2",{staticClass:"question-title"},[n._v("名校毕业的男性在择偶时是否看重学历？")]),n._v(" "),r("div",{staticClass:"answer"},[r("div",{staticClass:"meta"},[r("span",{staticClass:"author"},[n._v("知乎用户，")]),r("span",{staticClass:"bio"},[n._v("科研工作者")])]),n._v(" "),r("div",{staticClass:"content"},[r("p",[n._v("学历当然不重要，重要的是 Publication 好吧。")]),n._v(" "),r("p",[n._v("以后 Ph.D 找对象 都是如下套路：")]),n._v(" "),r("p",[n._v("a：听说你发了 Nature 正刊，还是 Cover，实在是太牛了。")]),n._v(" "),r("p",[n._v("b：哈哈哈，运气好而已。那你呢？")]),n._v(" "),r("p",[n._v("a：也就一篇 Nature Communication，还有一篇 Nature Nanotechnology 共同一作。")]),n._v(" "),r("p",[n._v("b：哦，挺好的。那你喜欢什么颜色啊？")]),n._v(" "),r("p",[n._v("a：蓝色。")]),n._v(" "),r("p",[n._v("b：对不起，我喜欢热情似火的红色，不喜欢悲伤的蓝色。我觉得咱两性格不合适，还是不要再见面了。")])])]),n._v(" "),r("img",{attrs:{src:t(353),height:"200",width:"200"}}),n._v(" "),r("div",{staticClass:"view-more"},[r("a",{attrs:{href:"http:\n      <!-- <!-- //www.zhihu.com/question/31222342"}},[n._v("查看知乎讨论"),r("span",{staticClass:"js-question-holder"})])]),n._v(" --> -->\n      ")])}]}}});